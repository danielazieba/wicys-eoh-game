<!DOCTYPE html>
<html>
<head>
<meta charset = "utf-8" name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Cybersecurity Breakfast Adventure</title>
<!-- Need the link tag to solve an error with favicon.ico: https://stackoverflow.com/questions/31075893/im-getting-favicon-ico-error -->
<link rel="shortcut icon" href="#"/>

<!-- Audio for sound effects: https://www.w3schools.com/tags/tag_audio.asp -->
<!-- Note: the type needs to be audio/mpeg instead of audio/wav for it to work -->
<!-- Use the loop functionality for the background music and the congratulatory music at the end-->
<audio loop = "true" id = "bgm">
  <source src="sounds/memories.mp3" type="audio/mpeg">
</audio>
<audio loop = "true" id = "congrats">
  <source src = "sounds/celebrate_clapping.mp3" type = "audio/mpeg">
</audio>
<!-- Audio for the puzzle tasks - include computer keystroke, lock opening successfully,
  lock closing, toaster pop up and the coffee being poured out -->
<audio id = "computer_audio">
  <source src="sounds/computer.wav" type="audio/mpeg">
</audio>
<audio id = "lock_audio">
  <source src="sounds/lock.wav" type="audio/mpeg">
</audio>
<audio id = "lock_open_audio">
  <source src="sounds/lock-open.wav" type="audio/mpeg">
</audio>
<audio id = "lock_fail_audio">
  <source src="sounds/lock-open-fail.wav" type="audio/mpeg">
</audio>
<audio id = "coffee_pour_audio">
  <source src="sounds/liquid-pour.wav" type="audio/mpeg">
</audio>
<audio id = "toaster_pop_up_audio">
  <source src="sounds/toaster-pop-up.wav" type="audio/mpeg">
</audio>

<style>
  /* style for entire webpage */
  body {
    background-color: black;
    text-align: center;
    color: white;
    font-family: courier;
  }

  /* style for guide hyperlinks */
  a
  {
    color: rgb(123, 213, 255);
  }

  /* source for how to style an element by id: https://blog.hubspot.com/website/css-id */
  /* style for scrolling text box (i.e. terminal) */
  #myTerminal {
    background-color: rgb(0, 8, 8);
    color: white;
    width: 605px;
    height: 377px;
    overflow-y: scroll;
    position: absolute;
    visibility: hidden;
    text-align: left;
    word-break: break-all;  /* allows wraparound without spaces - https://css-tricks.com/almanac/properties/o/overflow-wrap/*/
  }

  /* style the terminal files with respect to color code*/
  /* text: white , directory: blue, executable: white */
  .executable_file{
    color: limegreen;
  }
  .subdirectory{
    color: mediumblue;
  }

  /* source for how to style tab-related elements: https://www.w3schools.com/howto/howto_js_vertical_tabs.asp*/
  /* style the tab */
  .tab {
    float: left;
    border: 1px solid #ccc;
    background-color: #f1f1f1;

    width: 200px; /* width of tab */
    height: 500px; /* make the same as game canvas' height */
    position: absolute;
    visibility: hidden;
  }

  /* style the buttons inside the tab */
  .tab button {
    display: block;
    background-color: inherit;
    color: black;
    padding: 22px 16px;
    width: 100%;
    border: none;
    outline: none;
    text-align: left;
    cursor: pointer;
    /* transition: 0.3s; */
    font-size: 17px;
  }

  /* change background color of buttons on hover */
  .tab button:hover {
    background-color: #ddd;
  }

  /* create an active/current "tab button" class */
  .tab button.active {
    background-color: #ccc;
  }

  /* style the tab content */
  .tabcontent {
    float: left;
    padding: 0px 12px;
    border: 1px solid #ccc;
    border-left: none;

    width: 500px; /* width of tab content */
    height: 500px;  /* make the same as game canvas' height */
    position: absolute;

    visibility: hidden;
    background-color: white;
    color:black;
    text-align: left;
  }

  /* source for styling button: https://www.w3schools.com/css/css3_buttons.asp */
  .button {
    position: absolute;
    top: 90%;
    left: 50%;
    transform: translate(-50%, -50%);
    
    background-color: rgb(181, 255, 207);  /* 168, 255, 199 */
    color: black;
    font-size: 16px;
    padding: 16px 30px;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    text-align: center;
  }

  /* style the button on hover */
  .button:hover {
    background-color: rgb(168, 240, 194);
  }

  /*style for the list of hints*/
  .hint_list {
    color: black;
    width: 500px;
    height: 300px;
    overflow-y: scroll;
    visibility: hidden;
    text-align: left;
  }

  /* source for display parameter: https://stackoverflow.com/questions/2928688/how-to-hide-elements-without-having-them-take-space-on-the-page */
  .ongoing {
    visibility: visible;
    display: block;
  }

  /*separate out the styling for the html text based on classes*/
  .complete {
    visibility: hidden;
    display: none;
  }

/* this part of the code makes the canvas only show at the top of the page--cannot position it */
/* canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
} */

</style>
<!-- <link rel="stylesheet" href="css/alt.css"> -->
</head>
<!-- html text for when the game is ongoing, styled according to the "ongoing" class-->
<h1>Cybersecurity Breakfast Adventure</h1>
<p class="ongoing">Instructions: Use the arrow keys to navigate locations and complete your tasks. If you find yourself at a pop-up screen within the game, press Escape to close it and return to the overworld. For text-based prompts, hit Enter to submit your input.</p>

<!-- html text for when the game is complete styled according to the complete class-->
<h2 class="complete">CONGRATULATIONS!</h2>
<p class="complete">You've completed all the cybersecurity puzzles that need to be solved in order to make breakfast.</p>
<br class="complete">

<!-- creating the game terminal -->
<div id="myTerminal">
  <div id = "input0">~</div>
</div>

<!-- creating the hint view -->
<!-- source: https://www.w3schools.com/howto/howto_js_vertical_tabs.asp -->
<div class="tab">
  <button class="tablinks" onclick="viewHints(event, 'Computer')" id="defaultOpen">Unlocking the computer</button>
  <button class="tablinks" onclick="viewHints(event, 'Toast')">Making toast</button>
  <button class="tablinks" onclick="viewHints(event, 'Fridge')">Opening the fridge</button>
  <button class="tablinks" onclick="viewHints(event, 'Coffee')">Brewing coffee</button>
</div>

<!-- creating the structure of hints under each puzzle tab -->
<!-- adding in the html text to be shown when the tab is clicked and the "Get a Hint" button-->
<div id="Computer" class="tabcontent">
  <h3>Hints for computer puzzle</h3>
  <h4 id="Computer_hint_instruction">Click on the button below to get a hint for this puzzle. To go back to the game, press ESCAPE.</h4>
  <div class="hint_list" id="Computer_hint_listing"></div>
  <button class="button" id="Computer_btn" onclick="addHintToView(event, 'Computer')">Get a hint</button>
</div>

<div id="Toast" class="tabcontent">
  <h3>Hints for toast puzzle</h3>
  <h4 id="Toast_hint_instruction">Click on the button below to get a hint for this puzzle. To go back to the game, press ESCAPE.</h4>
  <div class="hint_list" id="Toast_hint_listing"></div>
  <button class="button" id="Toast_btn" onclick="addHintToView(event, 'Toast')">Get a hint</button>
</div>

<div id="Fridge" class="tabcontent">
  <h3>Hints for fridge puzzle</h3>
  <h4 id="Fridge_hint_instruction">Click on the button below to get a hint for this puzzle. To go back to the game, press ESCAPE.</h4>
  <div class="hint_list" id="Fridge_hint_listing"></div>
  <button class="button" id="Fridge_btn" onclick="addHintToView(event, 'Fridge')">Get a hint</button>
</div>

<div id="Coffee" class="tabcontent">
  <h3>Hints for coffee puzzle</h3>
  <h4 id="Coffee_hint_instruction">Click on the button below to get a hint for this puzzle. To go back to the game, press ESCAPE.</h4>
  <div class="hint_list" id="Coffee_hint_listing"></div>
  <button class="button" id="Coffee_btn" onclick="addHintToView(event, 'Coffee')">Get a hint</button>
</div>

<!-- creating a canvas: -->
<canvas id="myCanvas" width="700" height="500" style="background-color: #f1f1f1;"></canvas>
<!-- <script src="plugins.js"></script> -->
<br>
<!-- <body onload="startGame()"> -->
<body onload="start()">
<script>
  // get the canvas element and context (context allows you to draw on the canvas)
  const game_canvas = document.getElementById("myCanvas");
  const game_context = game_canvas.getContext("2d");
  const game_terminal = document.getElementById("myTerminal");


  /* HINT ATTRIBUTES */
  const hint_options = document.getElementsByClassName("tab");
  const hint_description = document.getElementsByClassName("tabcontent");
  const hint_list = document.getElementsByClassName("hint_list");
  let is_hint_view_displayed = false;

  /* variables to keep track of the current html text to be displayed */
  const ongoing_game_text = document.getElementsByClassName("ongoing");
  const completed_game_text = document.getElementsByClassName("complete");

  // Get the element with id="defaultOpen" and click on it
  document.getElementById("defaultOpen").click();

  // keeps track of what hints have been shown for a puzzle
  let current_hint_for_puzzle = {
    "Computer" : 0,
    "Toast" : 0,
    "Fridge" : 0,
    "Coffee" : 0
  }

  // hints for puzzles
  const hints = {
    "Computer" : [
      // unlock computer hints below
      "Try unlocking the computer.",
      "Go to the whiteboard to find clues for your password!",
      "Take a look at the Caesar Cipher guide!",
      "To decrypt Caesar Ciphers, you need to find the right amount of rotations made in the alphabet. How many lives does a cat have?",
      "How well do 9 rotations work on the whiteboard text?",
      "Try mapping A to J."
    ],
    "Toast" : [
      // make toast hints below
      "Go to the whiteboard to find the right number conversion for the lock.",
      "Take a look at the Number Systems and ASCII guide!",
      "The binary code given on the whiteboard translates to ‘hexadec’ in ASCII.",
      "The lock combination is in hexadecimal form. The correct combination is in decimal form."
    ],
    "Fridge" : [
      // unlock fridge hints below
      "Unlock the computer to access the terminal",
      "Use the terminal to try to access your smart fridge.",
      "Take a look at the CLI guide!",
      "Try the command 'ls' to see what is available to view in the system.",
      "Try the command 'cd <folder-name>' to navigate to the folder.",
      "Type ./<executable-file-name> to run the executable.",
      "Once you run the exe file, type “lock” to lock, and “unlock” to unlock your fridge."
    ],
    "Coffee" : [
      // brew coffee hints below
      "Unlock the computer to access the terminal",
      "Use the terminal to try to access your smart coffee brewer.",
      "Take a look at the CLI guide!",
      "Type 'exit' to return to the folder the executable file is located.",
      "Use the command 'cd ../' to navigate to the previous folder.",
      "Run 'lineDolphin.exe' to capture network traffic.",
      "Type 'capture' to see what GET request looks like!",
      "Run 'coffeeRequestSender.exe' to send a request to the coffee machine.",
      "To check the status, use the URL 'mycyba/brewer/status'. You can also brew coffee using a VERY similar URL.",
      "The host address is 'mycyba', port number is '5000', request type is 'GET', and URL is 'mycyba/brewer/brew'."
    ]
  }

  
  /* SCENE ATTRIBUTES */
  let hint_icon;
  let hint_x_pos = 660;
  let hint_y_pos = 5;

  // the following grouped variables store pics of the game scenes
  let start_scene;
  let bedroom_scene;
  let kitchen_scene;
  let livingroom_scene;
  let end_scene;

  // the following grouped variables store pics of zoomed in objects
  let whiteboard_scene;
  let computer_scene;
  let combo_lock_scene;
  let fridge_scene;
  let toaster_scene;
  let coffee_maker_scene;
  let terminal_scene;

  // the following grouped variables store pics of completed task images
  let fridge_complete_scene;
  let toaster_complete_scene;
  let coffee_maker_complete_scene;

  // booleans used for keeping track of current scene
  let is_start_scene = true;
  let is_bedroom_scene = false;
  let is_kitchen_scene = false;
  let is_livingroom_scene = false;
  let is_end_scene = false;

  // booleans used to keep track of current task pop upS
  let is_whiteboard_scene = false;
  let is_computer_scene = false;
  let is_combo_lock_scene = false;
  let is_fridge_scene = false;
  let is_toaster_scene = false;
  let is_coffee_maker_scene = false;
  let is_terminal_scene = false;


  let scene_pic;  // current background picture being displayed
  let current_room;  // current room the user is in (i.e. bedroom, kitchen, etc)


  /* CHARACTER ATTRIBUTES */
  let char_right1;  // stores pic of character facing right, step 1
  let char_right2;  // stores pic of character facing right, step 2
  let char_left1;  // stores pic of character facing left, step 1
  let char_left2;  // stores pic of character facing left, step 2

  // used to determine what direction and step the
  // current character image being displayed is
  let is_right1 = false;
  let is_right2 = false;
  let is_left1 = true;
  let is_left2 = false;

  let char_pic;  // current character picture being displayed

  let char_x_pos = 587;  // x pos of top left corner of char img
  let char_y_pos = 282;  // y pos of top left corner of char img

  const char_speed = 3;

  let step_counter = 0;  // used to determine whether the character step changes
  let step_change = 25;  // every 25 ms, character step changes

  // boolean variables representing if the specific arrow key is being pressed by user
  let is_key_up = false;
  let is_key_right = false;
  let is_key_down = false;
  let is_key_left = false;


  /* INTERACTIVE ATTRIBUTES (mostly bounds to interact with zoom-in items) */
  // hint icon interacted with using mouse clicker
  const hint_left_bound = 660;
  const hint_right_bound = 697;
  const hint_bottom_bound = 37;
  const hint_top_bound = 5;

  /* pop ups triggered by movement of the character close to the bounds*/
  // bedroom whiteboard
  const whiteboard_left_bound = 253;
  const whiteboard_right_bound = 408;
  const whiteboard_bottom_bound = 117;
  const whiteboard_top_bound = 0;

  // living room computer
  const computer_left_bound = 555;
  const computer_right_bound = 650;
  const computer_bottom_bound = 350;
  const computer_top_bound = 184;

  // kitchen combo lock
  const combo_lock_left_bound = 20;
  const combo_lock_right_bound = 75;
  const combo_lock_bottom_bound = 235;
  const combo_lock_top_bound = 175;

  // kitchen fridge
  const fridge_left_bound = 75;
  const fridge_right_bound = 205;
  const fridge_bottom_bound = 238;
  const fridge_top_bound = 46;

  // kitchen toaster
  const toaster_left_bound = 240;
  const toaster_right_bound = 310;
  const toaster_bottom_bound = 178;
  const toaster_top_bound = 100;

  // kitchen coffee maker
  const coffee_maker_left_bound = 450;
  const coffee_maker_right_bound = 560;
  const coffee_maker_bottom_bound = 178;
  const coffee_maker_top_bound = 80;


  /* MUSIC ATTRIBUTES */
  /* varibles to store the given music files (can be inserted using the .play() functionality) */
  const bgm = document.getElementById("bgm");
  const congrats = document.getElementById("congrats");
  const computer_sound = document.getElementById("computer_audio");
  const lock_sound = document.getElementById("lock_audio");
  const lock_open_sound = document.getElementById("lock_open_audio");
  const lock_fail_sound = document.getElementById("lock_fail_audio");
  const coffee_pour_sound = document.getElementById("coffee_pour_audio");
  const toaster_pop_sound = document.getElementById("toaster_pop_up_audio");


  /* PUZZLE ATTRIBUTES */
  // combinationn lock puzzle
  let allowed_combo_keys = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]  // e.which codes
  let lock_combo_string = " ";  // needs to have a space in between in order for backspace to work
  let is_lock_combo_incorrect_message_visible = false;              //to display incorrect message                  
  let is_lock_unlocked = false;       // to keep track of whether the puzzle is complete

  // computer password puzzle - only allowing capital letters
  let allowed_password_keys = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
                               83, 84, 85, 86, 87, 88, 89, 90] // e.which codes
  let computer_password_string = " ";  // needs to have a space in between in order for backspace to work
  let is_password_incorrect_message_visible = false;                  //to display incorrect message
  let is_computer_unlocked = false;        // to keep track of whether the puzzle is complete

  // terminal
  let current_directory = "~";                      //start in root directory always
  let directory_archive = ["~"];
  let subdirectories, executables_in_current;       // displays contents of current directory
  
  let currently_in_executable = false;
  let executing_ls_command = false;
  let curr_executable_name = "";
  
  let terminal_archive = [""];
  let user_input = "";                      //used to execute user input and display user input on the screen
  let num_inputs = 0;
  let input_number = num_inputs;  // used for moving between commands

  /* the directory tree structure - to access subdirectories and executables as needed*/
  const directory = {
    "~" : {
      "directories" : [
        "fridge_app"
      ],
      "executables" : [
        "lineDolphin.exe",
        "coffeeRequestSender.exe"
      ]
    },
    "fridge_app" : {
      "directories" : [],
      "executables" : [
        "fridgeLoginPortal.exe"
      ]
    }
  };

  /*terminal puzzle attributes*/
  /* to keep track of whether terminal tasks are completed*/
  let is_fridge_unlocked = false;
  let is_coffee_brewed = false;

  /* coffee brewing task- coffeeRequestSender user inputs stored here*/
  let current_coffee_state = "";
  let current_host_name = "";
  let current_port_name = "";
  let current_request_type = "";
  let current_request_url = "";

  /* outputs displayed when network traffic is captured from the lineDolphin executable */
  let display_coffee_text = false;
  const coffee_text = ["Pinging CYBA brewer using saved configuration...",
                        "Request sent:", 
                        "GET mycyba/brewer/status CYBA/1.5",
                        "Host: mycyba:5000", 
                        "Connection: keep-alive",
                        "...",
                        "CYBA/1.5 response received:",
                        "Host: mycyba",
                        "Port: 5000"
                        ];

  
  // FINAL ATTEMPT (SUCCESSFUL!!)
  console.log("BEGIN");

  // begins game
  function start() {
    console.log("starting")

    //load the hint icon to be diplayed in all ongoing game scenes
    hint_icon = loadCharacter("images/hint_icon_filled_64x64_x0.5.png", hint_x_pos, hint_y_pos, 32, 32);

    // load initial game setting components
    start_scene = loadBackground("images/ecebtext.png");
    bedroom_scene = loadBackground("images/bedroom.png");
    kitchen_scene = loadBackground("images/new_new_kitchen.png");
    livingroom_scene = loadBackground("images/big-out-living.png");
    end_scene = loadBackground("images/completed_breakfast_no_text.png");

    //load puzzle zoomed in images
    whiteboard_scene = loadBackground("images/whiteboard_w_lock_clue.png");
    computer_scene = loadBackground("images/locked_computer.png");
    combo_lock_scene = loadBackground("images/combination_lock_with_numbers_on_cabinet_w_box1.png");
    fridge_scene = loadBackground("images/fridge_display_w_text.png");
    toaster_scene = loadBackground("images/zoomed_in_toaster_with_background.png");
    coffee_maker_scene = loadBackground("images/coffee.png");
    terminal_scene = loadBackground("images/computer_screen.png");

    // load completed puzzle images
    fridge_complete_scene = loadBackground("images/fridge_completed.png");
    toaster_complete_scene = loadBackground("images/toaster_task_complete.png");
    coffee_maker_complete_scene = loadBackground("images/coffee_task_complete_w_text.png");


    // load initial character components
    char_right1 = loadCharacter("images/step1.png", char_x_pos, char_y_pos, 64, 64);
    char_right2 = loadCharacter("images/step2.png", char_x_pos, char_y_pos, 64, 64);
    char_left1 = loadCharacter("images/step1_left.png", char_x_pos, char_y_pos, 64, 64);
    char_left2 = loadCharacter("images/step2_left.png", char_x_pos, char_y_pos, 64, 64);

    // initialize values for starting game scene
    scene_pic = start_scene;
    current_room = start_scene;
    char_pic = char_left1;

    setInterval(update, 20)  // infinite loop, runs every 2 ms

    console.log("ending")
  }


  // updates game visuals and stats
  function update() {
    // step 1 - clear the canvas
    clearCanvas();

    // step 2 - update character position + scene
    moveCharacter();
    step_counter++;

    // update any task scene by switching in between puzzle images
    zoomInOnItem();

    // update game scene by switching between rooms
    changeRooms();

    // update positioning and visibility for terminal - ensure it overlaps game canvas
    // source1: https://www.w3schools.com/jsref/prop_element_offsettop.asp
    // source2: https://www.w3schools.com/jsref/prop_style_left.asp
    game_terminal.style.left = game_canvas.offsetLeft + 50 + "px";
    game_terminal.style.top = game_canvas.offsetTop + 54 + "px";

    // only display scrolling text box when terminal is open
    // source: https://stackoverflow.com/questions/21070101/show-hide-div-using-javascript
    if (is_terminal_scene) {
      game_terminal.style.visibility = "visible";
    } else {
      game_terminal.style.visibility = "hidden";
    }

    // update positioning of hint view
    positionHints();

    // step 3 - redraw
    // redraw scene
    draw(scene_pic, 0, 0, 700, 500);

    /*redraw character only if it is in a room - not a puzzle scene*/
    if (scene_pic == bedroom_scene || scene_pic == kitchen_scene || scene_pic == livingroom_scene) {  // only draw character if in a room
      draw(char_pic, char_x_pos, char_y_pos, 64, 64);
    }
    if (!is_start_scene && !is_end_scene) {
      draw(hint_icon, hint_x_pos, hint_y_pos, 32, 32);
    }
  

    // display text (needs to be after scene pics are drawn in order to be seen)
    displayUserInput();
    displayComboLockHint();
    displayIncorrectMessage();

    /* after redrawing and rendering text - checker to see if all tasks are done*/
    /* calls the function to check tasks completion and renders ending scene, music*/
    complete_game_scene();
    // can use to find current position of character
    // console.log("x: " + char_x_pos);
    // console.log("y: " + char_y_pos);
    console.log("CLEARED")
  }


  // clears canvas
  function clearCanvas() {
    // clears everything on the canvas
    game_context.clearRect(0, 0, 700, 500);
  }


  // moves character
  function moveCharacter() {
    // only allow to move the character when it is in a room and hint view is not displayed
    if (!is_hint_view_displayed && (scene_pic == bedroom_scene || scene_pic == kitchen_scene || scene_pic == livingroom_scene)) {  
      if (is_key_up && (char_y_pos - char_speed >= 0) && (char_y_pos - char_speed <= 436)) {
        char_y_pos -= char_speed;

        changeSteps(false, false, false);
      }

      /* enabled arrow keys for movement of the character if new position is within bounds */
      // move right 
      if (is_key_right && (char_x_pos + char_speed >= 0) && (char_x_pos + char_speed <= 636)) {
        char_x_pos += char_speed;

        changeSteps(true, false, (char_pic == char_left1 || char_pic == char_left2));
      }

      // move down
      if (is_key_down && (char_y_pos + char_speed >= 0) && (char_y_pos + char_speed <= 436)) {
        char_y_pos += char_speed;

        changeSteps(false, false, false);
      }

      // move left
      if (is_key_left && (char_x_pos - char_speed >= 0) && (char_x_pos - char_speed <= 636)) {
        char_x_pos -= char_speed;

        changeSteps(false, true, (char_pic == char_right1 || char_pic == char_right2));
      }
    }
  }


  /**
   * Changes the steps of the character to create an animation of the character walking.
   * 
   * @param is_moving_right Boolean representing if the user wants to move the character right
   * @param is_moving_left Boolean representing if the user wants to move the character left
   * @param is_changing Boolean that's true if the character is changing directions horizontally
   *   (i.e. if the character is moving from right to left or vice versa)
   */
  function changeSteps(is_moving_right, is_moving_left, is_changing) {
    // determine if steps are changed
    if (step_counter % step_change == 0 || is_changing) {
      if (!is_moving_right && !is_moving_left) {  // i.e. moving up or down
        if (is_right1) {
          // change char pic
          char_pic = char_right2;
          
          is_right2 = true;
          is_right1 = false;
        } else if (is_right2) {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_right2 = false;
        } else if (is_left1) {
          // change char pic
          char_pic = char_left2;

          is_left2 = true;
          is_left1 = false;
        } else if (is_left2) {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_left2 = false;
        }
      } else if (is_moving_right && !is_moving_left) {
        if (is_right1) {
          // change char pic
          char_pic = char_right2;
          
          is_right2 = true;
          is_right1 = false;
        } else if (is_right2) {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_right2 = false;
        } else {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_left1 = false;
          is_left2 = false;
        }
      } else if (is_moving_left && !is_moving_right) {
        if (is_left1) {
          // change char pic
          char_pic = char_left2;
          
          is_left2 = true;
          is_left1 = false;
        } else if (is_left2) {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_left2 = false;
        } else {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_right1 = false;
          is_right2 = false;
        }
      }
    }
  }


  // FUNCTIONS FOR HINTS
  function positionHints() {
    // update position of every element in 'tab' class
    // hint_options contains a list of the elements
    for (let puzzle_num = 0; puzzle_num < hint_options.length; ++puzzle_num) {
      hint_options[puzzle_num].style.left = game_canvas.offsetLeft + "px";
      hint_options[puzzle_num].style.top = game_canvas.offsetTop + "px";
    }
    
    // update position of every element in 'tab_content' class
    // hint_description contains a list of the elements
    for (let puzzle_hints = 0; puzzle_hints < hint_description.length; ++puzzle_hints) {
      hint_description[puzzle_hints].style.left = game_canvas.offsetLeft + 200 + "px"; /* 100 is the width of the tab, thus need that offset */
      hint_description[puzzle_hints].style.top = game_canvas.offsetTop + "px";
    }

    // update position of every element in 'hint_list' class
    for (let puzzle_list = 0; puzzle_list < hint_list.length; ++puzzle_list) {
      hint_list[puzzle_list].style.left = game_canvas.offsetLeft + 200 + "px"; /* 100 is the width of the tab, thus need that offset */
      hint_list[puzzle_list].style.top = game_canvas.offsetTop + 100 + "px";
    }
  }

  /*check for trigger being a mouseclick down on hint icon */
  game_canvas.addEventListener("mousedown", e => {

    // source: https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y
    let mouse_x = e.pageX - game_canvas.offsetLeft;
    let mouse_y = e.pageY - game_canvas.offsetTop;

    // if user clicks on hint icon, open up hint view
    if (!is_start_scene && !is_end_scene && !is_hint_view_displayed && mouse_x >= hint_left_bound && mouse_x <= hint_right_bound &&
        mouse_y >= hint_top_bound && mouse_y <= hint_bottom_bound) {

      changeHintVisibility("visible");
      is_hint_view_displayed = true;
    }

    console.log("mouse x: " + mouse_x);
    console.log("mouse y: " + mouse_y);
  })

  function changeHintVisibility(visibility) {
    // make every element in 'tab' class visible
    // hint_options contains a list of the elements
    for (let puzzle_num = 0; puzzle_num < hint_options.length; ++puzzle_num) {
      hint_options[puzzle_num].style.visibility = visibility;
    }
    
    // make every element in 'tab_content' class visible
    // hint_description contains a list of the elements
    for (let puzzle_hints = 0; puzzle_hints < hint_description.length; ++puzzle_hints) {
      hint_description[puzzle_hints].style.visibility = visibility;
    }

    // make every element in 'hint_list' class visible
    for (let puzzle_list = 0; puzzle_list < hint_list.length; ++puzzle_list) {
      hint_list[puzzle_list].style.visibility = visibility;
    }
  }

  // source for this function: https://www.w3schools.com/howto/howto_js_vertical_tabs.asp
  function viewHints(evt, puzzle_name) {
    let i, tabcontent, tablinks;
    
    // don't display any tab content for any tabs
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // inactivate all buttons for selecting hints for puzzles
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // display and activate the tab for the hint that is selected via mouse click
    // - will show that the hints for that puzzle is selected and display the hints
    //   for that puzzle
    document.getElementById(puzzle_name).style.display = "block";
    evt.currentTarget.className += " active";
  }

  function addHintToView(evt, puzzle_name) {
    // get the hints for the puzzle and the number of hints for the puzzle
    // that are displayed
    let hints_for_puzzle = hints[puzzle_name];
    let current_hint_location = current_hint_for_puzzle[puzzle_name];

    // display a new hint if there are any
    if (current_hint_location < hints_for_puzzle.length) {
      // repeat a hint if the user hasn't followed it yet
      if ((puzzle_name === "Fridge" || puzzle_name === "Coffee") && !is_computer_unlocked) {
        current_hint_for_puzzle[puzzle_name]--;
      }

      // get the element that lists the puzzle hints
      let puzzle_hint_listing = document.getElementById(puzzle_name + "_hint_listing");
    
      // get the new hint and increment the counter
      let new_hint = hints[puzzle_name][current_hint_location];
      current_hint_for_puzzle[puzzle_name]++;

      // display the hint
      puzzle_hint_listing.innerHTML += "- " + new_hint + "<br><br>";

      // scroll to display newest hint
      puzzle_hint_listing.scrollTop = puzzle_hint_listing.scrollHeight;
    }

    // if all hints are displayed, disable button to add hints
    if (current_hint_for_puzzle[puzzle_name] === hints_for_puzzle.length) {
      // disable button
      let puzzle_hint_btn = document.getElementById(puzzle_name + "_btn");
      puzzle_hint_btn.style.opacity = 0.6;
      puzzle_hint_btn.style.cursor = "not-allowed";

      // change instruction displayed
      let puzzle_hint_instr = document.getElementById(puzzle_name + "_hint_instruction");
      puzzle_hint_instr.innerHTML = "All hints for this puzzle are displayed below.  To go back to the game, press ESCAPE."
    }
  }


  /* check if the character landed in any zoom in area by triggering the bounds */
  function zoomInOnItem() {
    
    if (scene_pic == bedroom_scene && char_x_pos >= whiteboard_left_bound &&
      char_x_pos <= whiteboard_right_bound && char_y_pos <= whiteboard_bottom_bound) {

        // zoom into whiteboard - switch out of bedroom scene
        scene_pic = whiteboard_scene;
        // update scene images
        is_whiteboard_scene = true;
        is_bedroom_scene = false;
    }

    if (scene_pic == livingroom_scene && char_x_pos >= computer_left_bound && 
      char_x_pos <= computer_right_bound && char_y_pos <= computer_bottom_bound &&
      char_y_pos >= computer_top_bound) {
      
      if (!is_computer_unlocked) {
        // show computer lock screen - switch out of living room scene
        scene_pic = computer_scene;
        is_computer_scene = true;
        is_livingroom_scene = false;
      } else {
        // show terminal scene if computer is unlocked
        scene_pic = terminal_scene;
        is_terminal_scene = true;
        is_livingroom_scene = false;
      }
    }

    if (scene_pic == kitchen_scene && char_x_pos >= combo_lock_left_bound &&
      char_x_pos <= combo_lock_right_bound && char_y_pos <= combo_lock_bottom_bound &&
      char_y_pos >= combo_lock_top_bound) {
        
      if (!is_lock_unlocked) {
        //show combination lock task screen if it is unlocked
        scene_pic = combo_lock_scene
        is_combo_lock_scene = true;
        is_kitchen_scene = false;
      }

    }

    if (scene_pic == kitchen_scene && char_x_pos >= fridge_left_bound &&
      char_x_pos <= fridge_right_bound && char_y_pos <= fridge_bottom_bound &&
      char_y_pos >= fridge_top_bound) {

      // if fridge puzzle not completed, show locked screen
      if (!is_fridge_unlocked) {
        scene_pic = fridge_scene;
      } else {
        //else show completed fridge task screen
        scene_pic = fridge_complete_scene;
      }

      is_fridge_scene = true;
      is_kitchen_scene = false;
    }

    if (scene_pic == kitchen_scene && char_x_pos >= toaster_left_bound &&
      char_x_pos <= toaster_right_bound && char_y_pos <= toaster_bottom_bound &&
      char_y_pos >= toaster_top_bound) {
      
      // if combination lock is locked, show toaster wait screen
      if (!is_lock_unlocked) {
        scene_pic = toaster_scene;
      } else {
        //else show the toaster completed screen
        scene_pic = toaster_complete_scene;
      }

      is_toaster_scene = true;
      is_kitchen_scene = false;
    }

    if (scene_pic == kitchen_scene && char_x_pos >= coffee_maker_left_bound &&
      char_x_pos <= coffee_maker_right_bound && char_y_pos <= coffee_maker_bottom_bound &&
      char_y_pos >= coffee_maker_top_bound) {

        //if coffee request not made, show coffee maker scene
      if (!is_coffee_brewed) {
        scene_pic = coffee_maker_scene;
      } else {
        //else show coffee brewed scene
        scene_pic = coffee_maker_complete_scene;
      }
      
      is_coffee_maker_scene = true;
      is_kitchen_scene = false;
    }
  }


  /* RECORD KEY DOWNS (specifically character movements) */
  // source for recording key downs: https://stackoverflow.com/questions/39806858/how-to-use-arrow-keys-to-move-object-smoothly-in-canvas
  // source for stopping scrolling when using arrow keys: https://stackoverflow.com/questions/40905098/how-to-stop-scrolling-while-html5-game-is-playing
  document.onkeydown = function(event) {
    if (event.code === "ArrowUp") {
      is_key_up = true;
      event.preventDefault();
    }

    if (event.code === "ArrowRight") {
      is_key_right = true;
      event.preventDefault();
    }

    if (event.code === "ArrowDown") {
      is_key_down = true;
      event.preventDefault();
    }

    if (event.code === "ArrowLeft") {
      is_key_left = true;
      event.preventDefault();
    }
  }

  document.onkeyup = function(event) {
    if (event.code === "ArrowUp") {
      is_key_up = false;
    }

    if (event.code === "ArrowRight") {
      is_key_right = false;
    }

    if (event.code === "ArrowDown") {
      is_key_down = false;
    }

    if (event.code === "ArrowLeft") {
      is_key_left = false;
    }
  }


  /* RECORD KEY DOWNS (i.e. for closing windows, hints, etc) */
  // special key down - escape the zoomed in window, hints etc
  document.addEventListener('keydown', logKey)

  function logKey(key) {
    
    if (key.code === "Escape") {
      key.preventDefault();

      if (is_hint_view_displayed) {
        // close out hint view
        changeHintVisibility("hidden");
        is_hint_view_displayed = false;
      } else {
        if (is_whiteboard_scene) {
          // zoom out of whiteboard
          scene_pic = current_room;
          
          // need the following to prevent the character from triggering the zoom in again
          moveOutOfDetectionZone(whiteboard_left_bound, whiteboard_right_bound, whiteboard_bottom_bound, whiteboard_top_bound);

          // update values
          is_whiteboard_scene = false;
          if (current_room === bedroom_scene) {
            is_bedroom_scene = true;
          }
        }

        if (is_computer_scene) {  
          // zoom out of computer
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(computer_left_bound, computer_right_bound, computer_bottom_bound, computer_top_bound);

          // update values of the game scene
          is_computer_scene = false;
          if (current_room === livingroom_scene) {
            is_livingroom_scene = true;
          }

          // clear text
          computer_password_string = " ";
          if (is_password_incorrect_message_visible) {
            is_password_incorrect_message_visible = false;
          }
        }

        if (is_combo_lock_scene) {
          // zoom out of combo lock
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(combo_lock_left_bound, combo_lock_right_bound, combo_lock_bottom_bound, combo_lock_top_bound);

          // update values
          is_combo_lock_scene = false;
          if (current_room === kitchen_scene) {
            is_kitchen_scene = true;
          }

          // clear text
          lock_combo_string = " ";
          if (is_lock_combo_incorrect_message_visible) {
            is_lock_combo_incorrect_message_visible = false;
          }
        }

        if (is_fridge_scene) {
          // zoom out of fridge
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(fridge_left_bound, fridge_right_bound, fridge_bottom_bound, fridge_top_bound);

          // update values
          is_fridge_scene = false;
          if (current_room === kitchen_scene) {
            is_kitchen_scene = true;
          }
        }

        if (is_toaster_scene) {
          // zoom out of toaster
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(toaster_left_bound, toaster_right_bound, toaster_bottom_bound, toaster_top_bound);

          // update values
          is_toaster_scene = false;
          if (current_room === kitchen_scene) {
            is_kitchen_scene = true;
          }
        }

        if (is_coffee_maker_scene) {
          // zoom out of toaster
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(coffee_maker_left_bound, coffee_maker_right_bound, coffee_maker_bottom_bound, coffee_maker_top_bound);

          // update values
          is_coffee_maker_scene = false;
          if (current_room === kitchen_scene) {
            is_kitchen_scene = true;
          }
        }

        if (is_terminal_scene) {
          // zoom out of terminal
          scene_pic = current_room;

          // move out of the zone that triggered zoom in
          moveOutOfDetectionZone(computer_left_bound, computer_right_bound, computer_bottom_bound, computer_top_bound);

          // update values
          is_terminal_scene = false;
          if (current_room === livingroom_scene) {
            is_livingroom_scene = true;
          }

          // reset terminal history
          current_directory = "~";
          directory_archive = ["~"];
          terminal_archive = [""];
          user_input = "";
          currently_in_executable = false;

          // remove text from terminal display - https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
          while (num_inputs > 0) {
            let terminal_line = document.getElementById("input" + num_inputs);
            game_terminal.removeChild(terminal_line);

            let output_line = document.getElementById("output" + (num_inputs - 1));
            game_terminal.removeChild(output_line);
            
            --num_inputs;
          }
          input_number = num_inputs;
        }  // closing terminal conditional

      }  // closing conditional that checks if hints are displayed

    }  // closing the escape key conditional

    if (key.code === "Backspace") {

      if (is_combo_lock_scene) {
        if (is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = false;
        }

        if (lock_combo_string.length > 0) {
          // user only needs to delete the numbers they inputted, not the spaces
          if (lock_combo_string[lock_combo_string.length - 1] == " ") {
            lock_combo_string = lock_combo_string.substring(0, lock_combo_string.length - 1);
          }

          // delete a character
          lock_combo_string = lock_combo_string.substring(0, lock_combo_string.length - 1);
        }

        // play sound effect
        lock_sound.play();
      }  // closing lock scene conditional

      if (is_computer_scene) {
        if (is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = false;
        }

        if (computer_password_string.length <= 1) {
          // keep the blank space
          computer_password_string = " ";
        } else {
          // delete a character
          computer_password_string = computer_password_string.substring(0, computer_password_string.length - 1);
        }

        // play sound effect
        computer_sound.play();
      }  // closing computer scene conditional

      if (is_terminal_scene) {        
        // delete a character
        user_input = user_input.substring(0, user_input.length - 1);
      }

    }  // closing the backspace key conditional

    if (key.code === "Enter") {
      // to enter the game from start scene - press Enter
      if (is_start_scene) {
        //start in the bedroom scene and load bgm
        scene_pic = bedroom_scene;
        current_room = bedroom_scene;
        is_start_scene = false;
        is_bedroom_scene = true;
        // play bgm
        bgm.play();
      } else if (is_terminal_scene) {

        // execute user input and display the output onto terminal
        let terminal_output = executeUserInput();
        displayTerminalOutput(terminal_output);

        // remove cursor from current line, so it'll only be displayed on the next line
        // source: https://developer.mozilla.org/en-US/docs/Web/API/Node/lastChild
        let current_divider = document.getElementById("input" + num_inputs);
        current_divider.removeChild(current_divider.lastChild);

        // create new divider to hold next line of user input
        // source1: https://www.encodedna.com/javascript/append-or-add-text-to-div-using-javascript.htm
        // source2: https://developer.mozilla.org/en-US/docs/Web/API/Element/append
        let new_divider = document.createElement("div");
        ++num_inputs;
        new_divider.id = "input" + num_inputs;

        // display current directory for new line
        let directory_display = getFullDirectory()
        let text = document.createTextNode(directory_display);
        new_divider.appendChild(text);

        /*append the new divider containing terminal output and directory for new line
        to the game terminal. Scroll down to always display the new line  */
        game_terminal.append(new_divider);
        game_terminal.scrollTop = game_terminal.scrollHeight;  // scroll down to show the newly added element/line

        // reset user input text
        user_input = "";
        terminal_archive.push(user_input);
        input_number = num_inputs;

      } else {
        //else it is in combo lock scene or computer scene
        checkPasswordCorrectness();
      }
    }

    // check for key downs for alphanumeric characters
    updateUserInput(key);

  }  // closing log key function


  // moves the character out of the area that would trigger the zoom in again
  function moveOutOfDetectionZone(left_bound, right_bound, bottom_bound, top_bound) {
    // the following conditionals essentially check which direction the character
    // approached the item that caused it to zoom in; these checks will require
    // the user to only press 'ESCAPE' once when they want to close the window

    if (char_y_pos <= bottom_bound && char_y_pos + char_speed > bottom_bound) {
      // came from bottom
      char_y_pos += char_speed;
    } else if (char_x_pos >= left_bound && char_x_pos - char_speed < left_bound) {
      // came from left
      char_x_pos -= char_speed;
    } else if (char_x_pos <= right_bound && char_x_pos + char_speed > right_bound) {
      // came from right
      char_x_pos += char_speed;
    } else if (char_y_pos >= top_bound && char_y_pos - char_speed < top_bound) {
      // came from top
      char_y_pos -= char_speed;
    }
  }


  // initial loading and drawing of background
  function loadBackground(img_url) {
    const background_img = new Image();
    background_img.src = img_url;

    // load images first
    // - Note: the following line is needed to fix the problem of the background img not always
    // displaying when the page is refreshed
    // - Source: https://stackoverflow.com/questions/22889641/simple-html5-canvas-image-not-displaying
    background_img.addEventListener("load", drawBackground, false);

    console.log("loaded")

    function drawBackground() {
      console.log("drawing")

      // parameters of drawImage: image, x-coord-of-img, y-coord-of-img, img-width, img-height
      // game_context.drawImage(background_img, sx=0, sy=0, swidth=700, sheight=500);
      
      // draw(background_img, 0, 0, 700, 500)  // might not need...?

      console.log("finished")
    }

    return background_img;
    console.log("DRAWN");
  }


  // general function to initially load and draw components (i.e. character)
  function loadCharacter(img_url, x, y, width, height) {
    const img = new Image();
    img.src = img_url;

    // load images first
    // - Note: the following line is needed to fix the problem of the background img not always
    // displaying when the page is refreshed
    // - Source: https://stackoverflow.com/questions/22889641/simple-html5-canvas-image-not-displaying
    img.addEventListener("load", drawCharacter, false); 

    function drawCharacter() {
      // parameters of drawImage: image, x-coord-of-img, y-coord-of-img, img-width, img-height
      // game_context.drawImage(img, sx=x, sy=y, swidth=width, sheight=height);
      
      // draw(img, x, y, width, height);  // might not need...?
    }

    return img;
  }


  // need this function for redrawing images in infinite loop
  function draw(img, x, y, width, height) {
    game_context.drawImage(img, sx=x, sy=y, swidth=width, sheight=height);
  }

  console.log("OUT");

  // When moving between different rooms in the game through the doorways
  function changeRooms() {
    /* if character is currently in bedroom and within bounds of left door, enter living room */
    if (scene_pic == bedroom_scene && ((char_y_pos >= 125 && char_y_pos <= 205) && char_x_pos <= 5)){
      scene_pic = livingroom_scene;
      current_room = livingroom_scene;
      char_x_pos = 625;
      char_y_pos = 125
      is_bedroom_scene = false;
      is_livingroom_scene = true;
    }

    /* if character is currently in living room and within bounds of top door, enters kitchen*/
    if (scene_pic == livingroom_scene && ((char_x_pos >= 500 && char_x_pos <= 590) && char_y_pos <= 5) ){
      scene_pic = kitchen_scene;
      current_room = kitchen_scene;
      char_x_pos = 330;
      char_y_pos = 420;
      is_kitchen_scene = true;
      is_livingroom_scene = false;
    }
    /* if character is currently in the kitchen and within bounds of bottom door, then enters the living room */ 
    if (scene_pic == kitchen_scene && ((char_x_pos >= 280 && char_x_pos <= 380) && char_y_pos >= 430)){
      scene_pic = livingroom_scene;
      current_room = livingroom_scene;
      char_x_pos = 555;
      char_y_pos = 10;
      is_kitchen_scene = false;
      is_livingroom_scene = true;
    }

    /* if character is currently in the livingroom and within bounds of right door, enter bedroom */ 
    if (scene_pic == livingroom_scene && ((char_y_pos >= 107 && char_y_pos <= 160) && char_x_pos >= 630) ){
      scene_pic = bedroom_scene;
      current_room = bedroom_scene;
      char_x_pos = 10;
      char_y_pos = 155;
      is_bedroom_scene = true;
      is_livingroom_scene = false;
    }

  }


  /* FUNCTIONS FOR PUZZLES */
  // displays text user types
  function displayUserInput() {

    if (is_combo_lock_scene) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "black";
      game_context.fillText(lock_combo_string, 290, 443);
    }

    if (is_computer_scene) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "black";
      game_context.fillText(computer_password_string, 144, 270);
    }

    if (is_terminal_scene) {
      // source: https://developer.mozilla.org/en-US/docs/Web/API/Node/replaceChild

      // create the replacement elements
      let replacement_divider = document.createElement("div");
      let directory_display = getFullDirectory();
      let replacement_text = document.createTextNode(directory_display + user_input);
      // source for cursor block: https://www.w3schools.com/charsets/ref_utf_block.asp
      let cursor = document.createTextNode("\u258A");
      replacement_divider.appendChild(replacement_text);
      replacement_divider.appendChild(cursor);

      // retrieve the element to replace
      let divider_to_replace = document.getElementById("input" + num_inputs);

      // rename dividers so new divider will have original divider name (for consistency)
      divider_to_replace.id = "old" + num_inputs;
      replacement_divider.id = "input" + num_inputs;

      // replace current input line with updated user input
      game_terminal.replaceChild(replacement_divider, divider_to_replace);
    }

  }

  function displayIncorrectMessage() {

    // Check to see if the variable for whether message to be displayed is true
    if (is_lock_combo_incorrect_message_visible) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "red";
      //position the error message below the input box
      game_context.fillText("Combo incorrect. Please try again.", 150, 480);
    }

    if (is_password_incorrect_message_visible) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "red";
      //position the error message below the input box
      game_context.fillText("Password incorrect. Please try again.", 130, 350);
    }

  }
  
  // To display the numbers 56 25 31 on the top left - when the combo scene is displayed
  function displayComboLockHint() {
    if (is_combo_lock_scene) {
      game_context.font = "30px courier";
      game_context.fillStyle = "black";
      game_context.fillText("56 25 31", 10, 30);
    }
  }

  function updateUserInput(key) {

    if (key.code === "Space") {
      key.preventDefault();
    }

    if (is_combo_lock_scene) {
      if (allowed_combo_keys.includes(key.which) && lock_combo_string.length < 9) {
        // play sound effect of lock moving
        lock_sound.play();

        // remove incorrect message text
        if (is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = false;
        }

        // automatically add spaces between numbers for user
        if ((lock_combo_string.length) % 3 == 0) {
          lock_combo_string += " ";
        }

        // add user input
        lock_combo_string += String.fromCharCode(key.which);
      }
    }  // closing lock conditional

    if (is_computer_scene) {
      if (allowed_password_keys.includes(key.which) && computer_password_string.length < 18) {
        // play sound effect of typing keys
        computer_sound.play()

        // remove incorrect message text
        if (is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = false;
        }

        // add user input
        computer_password_string += String.fromCharCode(key.which);
      }    
    }  // closing computer password conditional

    if (is_terminal_scene) {
      
      if (key.key === "Shift" ||
          key.key === "Alt" ||
          key.key === "Meta" ||
          key.key === "Control" ||
          key.key === "Backspace" ||
          key.key === "Enter" ||
          key.key === "ArrowRight" ||
          key.key === "ArrowLeft" ||
          key.key === "Escape" ||
          key.key === "CapsLock") {
        // do nothing
      } else if (key.key === "ArrowUp") {
        // display previous terminal command from current command
        if (input_number - 1 >= 0) {
          user_input = terminal_archive[input_number - 1];
          --input_number;
        }
      } else if (key.key === "ArrowDown") {
        // display next terminal command from current command
        if (input_number + 1 <= num_inputs) {
          user_input = terminal_archive[input_number + 1];
          ++input_number;
        }
      } 
      // to do the tab autofill
      else if (key.key === "Tab") {

        // prevent default behavior
        key.preventDefault();

        // retrieve user-inputted command
        let command_to_process = [];
        if (user_input.trim() != "") {
          command_to_process = user_input.split(" ");
          console.log("COMMAND:" + command_to_process)
        }

        // retrieve directories and executables of current dir
        subdirectories = directory[current_directory]["directories"];
        executables_in_current = directory[current_directory]["executables"];
        
        if (command_to_process.length === 2) {  // can be ls or cd a directory
          if (command_to_process[0] === "cd" || command_to_process[0] === "ls") {
            // get work-in-progress directory name (i.e. what the user has typed out in the place of a dir)
            let possible_dir = command_to_process[1];

            // check if the work-in-progress directory is an actual subdirectory; if so, autocomplete
            // the user input to that directory
            for (let s = 0; s < subdirectories.length; ++s) {
              if (subdirectories[s].slice(0, possible_dir.length) === possible_dir) {
                // autocomplete directory name for user command
                user_input = command_to_process[0] + " " + subdirectories[s];
              }
            }
          }
        } else if (command_to_process.length === 1) {
          if (command_to_process[0].length > 2 && command_to_process[0].slice(0, 2) === "./") {
            // get work-in-progress executable name
            let possible_exe = command_to_process[0].slice(2, command_to_process[0].length);

            // check if the work-in-progress executable name is an actual executable; if so, autocomplete
            // the user input to that executable
            for (let e = 0; e < executables_in_current.length; ++e) {
              if (executables_in_current[e].slice(0, possible_exe.length) === possible_exe) {
                // autocomplete executable name for user command
                user_input = "./" + executables_in_current[e];
              }
            }
          }
        }
        
      } else {
        // add to user input and store it
        user_input += key.key;
        terminal_archive[num_inputs] = user_input;

        // make new command typed out the most recent command (used
        // for arrowup and arrowdown keys for viewing terminal archive)
        input_number = num_inputs;
      }
    }  // closing terminal conditional

  }

  // check passwords for combo lock and computer screen
  function checkPasswordCorrectness() {

    if (!is_lock_unlocked && is_combo_lock_scene) {
      if (lock_combo_string === " 86 37 49") {  // correct combo

        // zoom out of cabinet
        scene_pic = current_room;
        is_kitchen_scene = true;

        moveOutOfDetectionZone(combo_lock_left_bound, combo_lock_right_bound, combo_lock_bottom_bound, combo_lock_top_bound);

        //switch out of current room
        if (scene_pic === kitchen_scene) {
          is_combo_lock_scene = false;
        }

        // update status of puzzle
        is_lock_unlocked = true;
        document.getElementById("makeToast").innerHTML = " &#10004 Make Toast &#127838";
        
        // play sound effects
        lock_open_sound.play();
        toaster_pop_sound.play();

      } else {  // incorrect combo
        is_lock_combo_incorrect_message_visible = true;

        // play sound effects
        lock_fail_sound.play();
      }
    }  // closing lock conditional

    if (!is_computer_unlocked && is_computer_scene) {
     
      // check if the computer password string matches
      if (computer_password_string === " DELILAH") {

        // show terminal
        scene_pic = terminal_scene;
        is_terminal_scene = true;
        is_computer_scene = false;

        // update status of computer => unlocked
        is_computer_unlocked = true;
        document.getElementById("unlockComputer").innerHTML = " &#10004 Unlock the Computer &#128187";
      } else {  // incorrect password
        if (!is_password_incorrect_message_visible) {
          //make the checker for apssword message incorrect visible
          is_password_incorrect_message_visible = true;
        }
      }

    }  // closing computer password conditional

  }  // closing check password correctness function


  // execute user input by outputting corresponding messages
  function executeUserInput() {
    let command_to_process = [];
    user_input = user_input.trim();
    if (user_input != "") {
      command_to_process = user_input.split(" ");
      console.log("COMMAND:" + command_to_process)
    }
    let output_text = "";

    subdirectories = directory[current_directory]["directories"];
    executables_in_current = directory[current_directory]["executables"];

    // check commands
    if (command_to_process.length != 0) {  // only check commands if command exists
      
      if (currently_in_executable) {  // execute executable
        output_text = executeExecutable(command_to_process);
      } else if (command_to_process[0] === "cd") {
        output_text = executeCdCommand(command_to_process);
      } else if ((command_to_process.length === 1 || command_to_process.length === 2)
          && command_to_process[0].toLowerCase() == "ls") {  // "ls" or "ls" + valid_subdir_name
        output_text = executeLsCommand(command_to_process);
      } else if (command_to_process[0].slice(0, 2) === "./") {

        // check if given executable is in the current directory
        if (checkExecutableExistence(command_to_process[0].slice(2))) {
          // enter executable
          currently_in_executable = true;
          curr_executable_name = command_to_process[0].slice(2);
          console.log(curr_executable_name)
          output_text = getExecutableWelcomeMessage();
        } else {
          output_text = "Error: specified executable does not exist.";
        }

      } else if (command_to_process.length === 1 && command_to_process[0].toLowerCase() === "exit") {
        output_text = "Error: nothing to exit from.";
      } else {
        output_text = "Error: Invalid Command";
      }

    }

    return output_text;
  }

  function executeCdCommand(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1) {  // "cd"

      // move to home directory if not already in it
      if (current_directory != "~") {
        current_directory = "~";
        directory_archive = ["~"];
      }

    } else if (command_to_process.length === 2) {  // "cd" + other command

      if (command_to_process[1] == "../") {  // "cd ../"
        if (current_directory != "~" && directory_archive.length != 1) {
          // move to parent/previous directory
          directory_archive.pop();
          current_directory = directory_archive[directory_archive.length - 1];
        }
      } else {  // check if it's a valid directory (i.e. if the user wants to move into a directory)
        let valid_directory = false;

        for (let s = 0; s < subdirectories.length; ++s) {
          if (subdirectories[s] === command_to_process[1]) {
            // change directory and save into archive
            current_directory = subdirectories[s];
            directory_archive.push(current_directory);
            valid_directory = true;
            break;
          }
        }

        if (!valid_directory) {
          output_text = "Error: specified directory not found.";
        }
      }

    } else {
      output_text = "Error: Invalid Command";
    }

    return output_text;
  }

  function executeLsCommand(command_to_process) {
    executing_ls_command = true;
    let output_text = "";

    if (command_to_process.length === 1) {  // "ls"
      // display subdirectories and executables in current directory
      for (let i = 0; i < subdirectories.length; ++i) {
        output_text += subdirectories[i] + " ";
      }

      for (let j = 0; j < executables_in_current.length; ++j) {
        output_text += executables_in_current[j] + " ";
      }
    } else {  // "ls" + valid_subdir_name
      let dir = command_to_process[1];

      // check if the given directory is a valid subdirectory
      let is_subdirectory = false;
      for (let d = 0; d < subdirectories.length; ++d) {
        if (dir === subdirectories[d]) {
          is_subdirectory = true;
        }
      }

      // list out contents in the specified directory
      if (is_subdirectory) {
        let dir_contents = directory[dir];

        for (let i = 0; i < dir_contents["directories"].length; ++i) {
          output_text += dir_contents["directories"][i] + " ";
        }

        for (let j = 0; j < dir_contents["executables"].length; ++j) {
          output_text += dir_contents["executables"][j] + " ";
        }
      }
    }
    

    return output_text;
  }

  function executeExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1 && command_to_process[0] === "exit") {
      currently_in_executable = false;
      current_coffee_state = "";
      output_text = "Exiting current executable.";
    } else {
      // redirect to the specific executable
      if (curr_executable_name === "lineDolphin.exe") {
        output_text = executeLineDolphinExecutable(command_to_process);
      } else if (curr_executable_name === "coffeeRequestSender.exe") {
        output_text = executeCoffeeRequestExecutable(command_to_process);
      } else if (curr_executable_name === "fridgeLoginPortal.exe") {
        output_text = executeFridgeLoginExecutable(command_to_process);
      }
    }

    return output_text;
  }

  function executeLineDolphinExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1 && command_to_process[0].toLowerCase() === "capture") {
      display_coffee_text = true;

      output_text = "STATUS: OK, READY TO BREW";
    } else {
      output_text = "Error: Invalid Command";
    }

    return output_text;
  }

  function executeCoffeeRequestExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process[0].toLowerCase() === "start" && current_coffee_state === "") {
      output_text = "What host would you like to send a request to?";
      current_coffee_state = "port";
    } else if (current_coffee_state === "port") {
      current_host_name = command_to_process[0].toLowerCase();
      output_text = "Which port number are you sending to?";
      current_coffee_state = "type";
    } else if (current_coffee_state === "type") {
      current_port_name = command_to_process[0].toLowerCase();
      output_text = "What type of request are you sending? (GET or POST)";
      current_coffee_state = "url";
    } else if (current_coffee_state === "url") {
      current_request_type = command_to_process[0].toLowerCase();
      output_text = "Which URL are you sending this request to?";
      current_coffee_state = "process";
    } else if (current_coffee_state === "process") {
      current_request_url = command_to_process[0].toLowerCase();

      // now we have all info, process and set error messages accordingly
      output_text = processCoffeeRequest();

      // reset coffee state
      current_coffee_state = "";
    } else {
      output_text = "Error: invalid command.";
      current_coffee_state = "";
    }

    return output_text;
  }

  /* Verifies if the user's request is valid and outputs the corresponding message status or error */
  function processCoffeeRequest() {
    let output_text = "";

    if (current_host_name != "mycyba") {
      output_text = "Error: could not reach specified host.";
    } else if (current_port_name != "5000") {
      output_text = "Error: host is reachable, but port number is incorrect.";
    } else if (current_request_type != "get") {
      output_text = "Error: not the expected request type.";
    } else if (current_request_url === "mycyba/brewer/brew") {
      output_text = "STATUS: BREW REQUEST RECEIVED. WILL PROCEED TO FULFILL REQUEST.";

      // update puzzle status
      is_coffee_brewed = true;
      document.getElementById("makeCoffee").innerHTML = " &#10004 Make Coffee &#9749";

      // play sound effect
      coffee_pour_sound.play();

    } else if (current_request_url === "mycyba/brewer/status") {
      output_text = "STATUS: OK, READY TO BREW";
    } else {
      output_text = "Error: valid request, but invalid URL.";
    }

    return output_text;
  }

  // to execute the script for Fridge Login to fridge_app
  function executeFridgeLoginExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1 && command_to_process[0] === "stock") {
      // if the command is stock, display fridge contents
      output_text = "Current fridge contents: 1x baking soda. 6x bell pepper. 3x Golden Harbor Soup Dumplings. 1x half and half. 34x chicken eggs. 10x quail eggs.";
    
    } else if (command_to_process.length === 1 && command_to_process[0] === "lock") {
      //check if fridge is locked
      if (!is_fridge_unlocked) {
        output_text = "Fridge is already locked!";
      } else {
        //if it isn't, lock the fridge and play the lock sounds
        output_text = "Fridge locked!";
        is_fridge_unlocked = false;

        //sound effect of lock closing
        lock_fail_sound.play();
      }

    } else if (command_to_process.length === 1 && command_to_process[0] === "unlock") {
      // if the command is to unlock
      if (!is_fridge_unlocked) {
        output_text = "Fridge unlocked!";

        // update puzzle status
        is_fridge_unlocked = true;
        document.getElementById("openFridge").innerHTML = " &#10004 Open the Fridge &#127859";

        // play sound effects
        lock_open_sound.play()
      } else {
        output_text = "Fridge is already unlocked!";
      }

    } else {
      // all other commands are invalid
      output_text = "Error: Invalid Command";
    }

    return output_text;
  }

  function checkExecutableExistence(executable_name) {
    // to see if the executable exists in the current directory
    for (let i = 0; i < executables_in_current.length; ++i) {
      if (executable_name === executables_in_current[i]) {
        return true;
      }
    }

    return false;
  }

  function getExecutableWelcomeMessage() {
    // Default welcome message when starting running a executable file
    if (curr_executable_name === "lineDolphin.exe") {
      return "Welcome to lineDolphin! Default configuration: display CyberCoffee traffic.";
    } else if (curr_executable_name === "coffeeRequestSender.exe") {
      return "Welcome to the coffee request portal! Here, one can send requests to the CYBA coffee brewer.";
    } else if (curr_executable_name === "fridgeLoginPortal.exe") {
      //return "Welcome to your smart fridge portal! Your username is GreenStreet. However, to access fridge features, you must authenticate yourself.";
      return "Welcome to your smart fridge control portal!";
    }
  }

  // display output message for a terminal command
  function displayTerminalOutput(output_text) {
    // create divider to store output
    let output_divider = document.createElement("div");
    output_divider.id = "output" + num_inputs;

    if (display_coffee_text) {
      // output coffee brew message
      for (let i=0; i < coffee_text.length; ++i) {
        let line_of_coffee_text = document.createTextNode(coffee_text[i]);
        output_divider.appendChild(line_of_coffee_text);
        output_divider.appendChild(document.createElement("br"))
      }

      display_coffee_text = false;
    }

    //check to see if it is executing a ls command, then display 
    // directories and executables in color and append to output_divider
    if(executing_ls_command){
      color_directory_executable(output_text, output_divider);
      executing_ls_command = false;
    }
    // if it is executing ls command, do not make it into a TextNode
    else{
      let text = document.createTextNode(output_text);
      output_divider.appendChild(text);
    }
    // add to terminal
    game_terminal.append(output_divider);
  }

  function color_directory_executable(output_text, output_divider){
    let directory_contents = [];
    // split the output of contents of the directory - after ls command is executed
    output_text = output_text.trim();
    if (output_text != "") {
      directory_contents = output_text.split(" ");
    }

    // create span and append to the output divides based on class
    for(let index = 0; index < directory_contents.length; index++){

      // to create the span element: https://stackoverflow.com/questions/5802663/create-a-span-element-inside-another-element-using-javascript
      // color the text different based on class - directory and executable
      let ls_span = document.createElement("span");
      let check_exe_file = directory_contents[index].slice(-4);
      if(check_exe_file === ".exe"){
        ls_span.className = "executable_file";
      }
      else{
        ls_span.className = "subdirectory";
      }
      //append to the divider after setting the colors
      ls_span.innerHTML = directory_contents[index] + " ";
      output_divider.appendChild(ls_span);
    }
  }

  // returns a string of the full directory to display in terminal
  function getFullDirectory() {
    let directory_string = directory_archive[0];  // "~" directory

    if (currently_in_executable) {
      directory_string = curr_executable_name + "> ";
    } else {
      // add in rest of directories
      for (let dir = 1; dir < directory_archive.length; ++dir) {
        directory_string += "/" + directory_archive[dir]; 
      }
      
      // to display end of the current working directory path
      directory_string += "$ ";
    }

    return directory_string;
  }

  function complete_game_scene(){
    // check to see if all tasks are completed
    if (is_computer_unlocked && is_lock_unlocked && is_coffee_brewed && is_fridge_unlocked) {
      // change scene
      scene_pic = end_scene;
      current_room = end_scene;
      is_end_scene = true;
      is_bedroom_scene = false;
      is_kitchen_scene = false;
      is_livingroom_scene = false;
      is_terminal_scene = false;

      // update html text
      for (let task = 0; task < ongoing_game_text.length; ++task) {
        ongoing_game_text[task].style.visibility = "hidden";
        ongoing_game_text[task].style.display = "none";
      }

      // block the appropriate html text according to class
      for (let text = 0; text < completed_game_text.length; ++text) {
        completed_game_text[text].style.visibility = "visible";
        completed_game_text[text].style.display = "block";
      }
      // stop the background music and play congrats theme
      bgm.pause();
      congrats.play();
    }
  }


  // Notes for incorporating password puzzles:
  // done - create a variable containing an array of allowed keys (can use same as last year's)
  // done - create associated variables for keeping track of the password, incorrect message, and
  //   whether item has been unlocked
  // done - add conditional that prevents zoom in once puzzle is solved in zoomInOnItem()
  // done - add line that clears the text in ESCAPE key down for the item
  // done - add conditional for item in BACKSPACE key down (code should be similar to that of last year)
  // - add respective text/code to...
  // done  - updateUserInput()
  // done  - displayUserInput() /
      //check positioning of password
  // done  - displayIncorrectMessage()
  // done - checkPasswordCorrectness()
  //     - code should be similar to that of last year--refer to line 215 in original code


  //done - Suggested sequence that I kind of followed when trying to implement the puzzle:
  // - adjust text size and position using a default text (i.e. set the variable to
  //   some phrase for testing without taking in user input yet)
  // - incorporate taking user input
  // - incorporate key downs for backspace, enter, etc


  // Notes to self (Megan):
  // - create helper function for closing out of lock scene (maybe)


  // Notes for terminal implementation (7/3):
  // DONE - render and position terminal
  // DONE - find out how to wrap text when there is no space
  // DONE - remove browser detection for SPACE (like we did when using the arrow keys)
  // DONE - find way to keep track of user input so when commands like ESCAPE or RETURN
  //   are pressed, it performs the way it does in a terminal (i.e. clears terminal history
  //   and shows new line with directory)
  // DONE - set up display (~)
  // DONE - implement ENTER key down
  // DONE - take in user input
  // DONE - implement ESCAPE key down
  // DONE - fill in allowed keys
  //   DONE - fix these keys: minus, quote, period, slash
  // DONE - implement basic terminal commands
  //   DONE - cd
  //   DONE - ls
  //   DONE - cd ../
  //   DONE - KEY UP (to get previously used commands)
  //   DONE - KEY DOWN (to get next commands if looking at previous commands)
  // DONE - fix scrolling functionality (to have it scroll to show the line that is being written)
  // DONE - display a cursor for the user
  // DONE - adjust positioning and color of terminal (i.e. to make it look like it's being viewed
  //   from a computer)
  // - make sure functionality works properly (when using backspace and
  //   escaping the window)
  // - fix backspace key down for computer and combo puzzle
  // - allow cursor to move left and right


  // TODO for hints:
  // DONE - add hints in
  // DONE - show tab changes with corresponding descriptions displaying


  // DURING LAST WEEK:
  // - remove commented out code
  // - remove console.logs
  // - check through all code + add missing comments + test thoroughly

</script>

<!-- The rest of the HTML text after displaying the canvas -->
<!--Display tasks and resource links when the game is ongoing -->
  <div class="ongoing" id="taskList">
    <p class="ongoing">Remaining tasks:</p>
    <p class="ongoing" id="unlockComputer">- Unlock the Computer &#128187</p>
    <p class="ongoing" id="makeToast">- Make Toast &#127838 </p>
    <p class="ongoing" id="openFridge">- Open the Fridge &#127859</p>
    <p class="ongoing" id="makeCoffee">- Make Coffee &#9749</p>
  </div>

  <!-- Display the below HTML text when the game is completed-->
  <p class="complete">We took inspiration from Capture The Flag (CTF) competitions in designing the puzzles you just solved and tried to make them a bit beginner-friendly. CTF competitions are a great way to learn more about cybersecurity, though they definitely aren't the only way.</p>
  <br class="complete">
  <p class="complete">Or, if you're not into CTFs, some things you can do are generally learn more about operating systems (especially Linux), improve your programming skills, read CTF challenge write-ups, or watch talks from DEF CON (an annual security conference) to get inspired about interesting security topics.</p>
  <br class="complete">
  <p class="complete">Some additional links:</p>
  <p class="complete">- <a href="https://overthewire.org/wargames/">https://overthewire.org/wargames/</a> is a great way to gain confidence navigating the Linux command-line and learning some common code exploits.</p>
  <p class="complete">- <a href="https://picoctf.org/">https://picoctf.org/</a> is a fantastic starting point if you want to dive a bit deeper than our game goes.</p>
  <p class="complete">- <a href="https://ctftime.org/">https://ctftime.org/</a> lists upcoming CTFs if you’re looking for more past picoCTF.</p>
  <br>

  <!-- Display below resources text and links for both when game is ongoing and complete-->
  <div id="resources">
    <p>Resources</p>
    <p><a href="guides/caesar_ciphers.pdf" target="_blank" rel="noopener noreferrer">On Caesar Ciphers</a></p>
    <p><a href="guides/number_systems_and_ascii.pdf" target="_blank" rel="noopener noreferrer">Number Systems and ASCII</a></p>
    <p><a href="guides/cli.pdf" target="_blank" rel="noopener noreferrer">Navigating a Command-Line Interface</a></p>
  </div>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset = "utf-8" name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Cybersecurity Breakfast Adventure</title>
<style>
  /* style for entire webpage */
  body {
    background-color: black;
    text-align: center;
    color: white;
    font-family: courier;
  }

  /* style for guide hyperlinks */
  a
  {
    color: rgb(123, 213, 255);
  }

  /* source for how to style an element by id: https://blog.hubspot.com/website/css-id */
  /* style for scrolling text box (i.e. terminal) */
  #myTerminal {
    background-color: darkgray;
    width: 700px;
    height: 500px;
    overflow-y: scroll;
    position: absolute;
    visibility: hidden;
    text-align: left;
    word-break: break-all;  /* allows wraparound without spaces - https://css-tricks.com/almanac/properties/o/overflow-wrap/*/
  }

/* this part of the code makes the canvas only show at the top of the page--cannot position it */
/* canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
} */
</style>
<!-- <link rel="stylesheet" href="css/alt.css"> -->
</head>
  <h2>Cybersecurity Breakfast Adventure</h2>
  <h3>*For the best user experience, please use Mozilla Firefox. The game has experienced some issues in Google Chrome and Safari. If you ever have problems of the character getting stuck in place or the screen going black, please refresh the page. Note that your current progress in the game will be lost when the page is refreshed.*</h3>
<p>Instructions: Use the arrow keys to navigate locations and complete your tasks. If you find yourself at a pop-up screen within the game, press Escape to close it and return to the overworld. For text-based prompts, hit Enter to submit your input.</p>
<div id="myTerminal">
  <div id = "input0">~</div>
</div>
<!-- creating a canvas: -->
<canvas id="myCanvas" width="700" height="500" style="background-color: #f1f1f1;"></canvas>
<!-- <script src="plugins.js"></script> -->
<br>
<!-- <body onload="startGame()"> -->
<body onload="start()">
<script>
  // get the canvas element and context (context allows you to draw on the canvas)
  const game_canvas = document.getElementById("myCanvas");
  const game_context = game_canvas.getContext("2d");
  const game_terminal = document.getElementById("myTerminal");

  
  /* SCENE ATTRIBUTES */
  // the following grouped variables store pics of the game scenes
  let bedroom_scene;
  let kitchen_scene;
  let livingroom_scene;

  // the following grouped variables store pics of zoomed in objects
  let whiteboard_scene;
  let computer_scene;
  let combo_lock_scene;
  let fridge_scene;
  let toaster_scene;
  let coffee_maker_scene;
  let terminal_scene;

  // booleans used for keeping track of current scene
  let is_bedroom_scene = true;
  let is_kitchen_scene = false;
  let is_livingroom_scene = false;

  let is_whiteboard_scene = false;
  let is_computer_scene = false;
  let is_combo_lock_scene = false;
  let is_fridge_scene = false;
  let is_toaster_scene = false;
  let is_coffee_maker_scene = false;
  let is_terminal_scene = false;


  let scene_pic;  // current background picture being displayed
  let current_room;  // current room the user is in (i.e. bedroom, kitchen, etc)


  /* CHARACTER ATTRIBUTES */
  let char_right1;  // stores pic of character facing right, step 1
  let char_right2;  // stores pic of character facing right, step 2
  let char_left1;  // stores pic of character facing left, step 1
  let char_left2;  // stores pic of character facing left, step 2

  // used to determine what direction and step the
  // current character image being displayed is
  let is_right1 = false;
  let is_right2 = false;
  let is_left1 = true;
  let is_left2 = false;

  let char_pic;  // current character picture being displayed

  let char_x_pos = 587;  // x pos of top left corner of char img
  let char_y_pos = 282;  // y pos of top left corner of char img

  const char_speed = 3;

  let step_counter = 0;  // used to determine whether the character step changes
  let step_change = 25;  // every 25 ms, character step changes

  // boolean variables representing if the specific arrow key is being pressed by user
  let is_key_up = false;
  let is_key_right = false;
  let is_key_down = false;
  let is_key_left = false;


  /* INTERACTIVE ATTRIBUTES (mostly bounds to interact with zoom-in items) */
  // bedroom whiteboard
  const whiteboard_left_bound = 253;
  const whiteboard_right_bound = 408;
  const whiteboard_bottom_bound = 117;
  const whiteboard_top_bound = 0;

  // living room computer
  const computer_left_bound = 555;
  const computer_right_bound = 650;
  const computer_bottom_bound = 350;
  const computer_top_bound = 184;

  // kitchen combo lock
  const combo_lock_left_bound = 20;
  const combo_lock_right_bound = 75;
  const combo_lock_bottom_bound = 235;
  const combo_lock_top_bound = 175;

  // kitchen fridge
  const fridge_left_bound = 75;
  const fridge_right_bound = 205;
  const fridge_bottom_bound = 238;
  const fridge_top_bound = 46;

  // kitchen toaster
  const toaster_left_bound = 240;
  const toaster_right_bound = 310;
  const toaster_bottom_bound = 178;
  const toaster_top_bound = 100;

  // kitchen coffee maker
  const coffee_maker_left_bound = 450;
  const coffee_maker_right_bound = 560;
  const coffee_maker_bottom_bound = 178;
  const coffee_maker_top_bound = 80;


  /* PUZZLE ATTRIBUTES */
  // combinationn lock puzzle
  let allowed_combo_keys = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]  // e.which codes
  let lock_combo_string = " ";  // needs to have a space in between in order for backspace to work
  let is_lock_combo_incorrect_message_visible = false;
  let is_lock_unlocked = false;

  // computer password puzzle
  let allowed_password_keys = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
                               83, 84, 85, 86, 87, 88, 89, 90] // e.which codes
  let computer_password_string = " ";  // needs to have a space in between in order for backspace to work
  let is_password_incorrect_message_visible = false;
  let is_computer_unlocked = false;

  // terminal
  let current_directory = "~";
  let directory_archive = ["~"];
  let terminal_archive = [""];
  let currently_in_executable = false;
  let curr_executable_name = "";
  let display_coffee_text = false;
  let fridge_is_locked = true;
  let user_input = "";
  let num_inputs = 0;
  let input_number = num_inputs;  // used for moving between commands

  const directory = {
    "~" : {
      "directories" : [
        "fridge_app"
      ],
      "executables" : [
        "lineDolphin.exe",
        "coffeeRequestSender.exe"
      ]
    },
    "fridge_app" : {
      "directories" : [],
      "executables" : [
        "fridgeLoginPortal.exe"
      ]
    }
  };

  const coffee_text = ["Pinging CYBA brewer using saved configuration...",
                        "Request sent:", 
                        "GET mycyba/brewer/status CYBA/1.5",
                        "Host: mycyba:5000", 
                        "Connection: keep-alive",
                        "...",
                        "CYBA/1.5 response received:",
                        "Host: mycyba",
                        "Port: 5000"
                        ];

  
  // FINAL ATTEMPT (SUCCESSFUL!!)
  console.log("BEGIN");

  // begins game
  function start() {
    console.log("starting")

    // load initial game setting components
    bedroom_scene = loadBackground("images/bedroom.png");
    kitchen_scene = loadBackground("images/new_new_kitchen.png");
    livingroom_scene = loadBackground("images/big-out-living.png");

    // zoomed in images
    whiteboard_scene = loadBackground("images/whiteboard_w_lock_clue.png");
    computer_scene = loadBackground("images/locked_computer.png");
    combo_lock_scene = loadBackground("images/combination_lock_with_numbers_on_cabinet_w_box1.png");
    fridge_scene = loadBackground("images/fridge_display_w_text.png");
    toaster_scene = loadBackground("images/zoomed_in_toaster_with_background.png");
    coffee_maker_scene = loadBackground("images/coffee.png");
    terminal_scene = loadBackground("images/terminal.png");

    // load initial character components
    char_right1 = loadCharacter("images/step1.png", char_x_pos, char_y_pos, 64, 64);
    char_right2 = loadCharacter("images/step2.png", char_x_pos, char_y_pos, 64, 64);
    char_left1 = loadCharacter("images/step1_left.png", char_x_pos, char_y_pos, 64, 64);
    char_left2 = loadCharacter("images/step2_left.png", char_x_pos, char_y_pos, 64, 64);
    
    // initialize values
    scene_pic = bedroom_scene;
    current_room = bedroom_scene;
    char_pic = char_left1;

    setInterval(update, 20)  // infinite loop, runs every 2 ms

    console.log("ending")
  }


  // updates game visuals and stats
  function update() {
    // step 1 - clear the canvas
    clearCanvas();

    // step 2 - update character position + scene
    moveCharacter();
    step_counter++;

    zoomInOnItem();

    // update game scene by switching between rooms
    changeRooms();

    // update positioning and visibility for terminal - ensure it overlaps game canvas
    // source1: https://www.w3schools.com/jsref/prop_element_offsettop.asp
    // source2: https://www.w3schools.com/jsref/prop_style_left.asp
    game_terminal.style.left = game_canvas.offsetLeft + "px";
    game_terminal.style.top = game_canvas.offsetTop + "px";

    // only display scrolling text box when terminal is open
    // source: https://stackoverflow.com/questions/21070101/show-hide-div-using-javascript
    if (is_terminal_scene) {
      game_terminal.style.visibility = "visible";
    } else {
      game_terminal.style.visibility = "hidden";
    }

    // step 3 - redraw
    // redraw scene
    draw(scene_pic, 0, 0, 700, 500);
    // redraw character
    if (scene_pic == bedroom_scene || scene_pic == kitchen_scene || scene_pic == livingroom_scene) {  // only draw character if in a room
      draw(char_pic, char_x_pos, char_y_pos, 64, 64);
    }

    // display text (needs to be after scene pics are drawn in order to be seen)
    displayUserInput();
    displayIncorrectMessage();

    // can use to find current position of character
    // console.log("x: " + char_x_pos);
    // console.log("y: " + char_y_pos);

    console.log("CLEARED")
  }


  // clears canvas
  function clearCanvas() {
    // clears everything on the canvas
    game_context.clearRect(0, 0, 700, 500);
  }


  // moves character
  function moveCharacter() {
    //only allow to move the character when it is in a room
    if (scene_pic == bedroom_scene || scene_pic == kitchen_scene || scene_pic == livingroom_scene) {  
      if (is_key_up && (char_y_pos - char_speed >= 0) && (char_y_pos - char_speed <= 436)) {
        char_y_pos -= char_speed;

        changeSteps(false, false, false);
      }

      // move right
      if (is_key_right && (char_x_pos + char_speed >= 0) && (char_x_pos + char_speed <= 636)) {
        char_x_pos += char_speed;

        changeSteps(true, false, (char_pic == char_left1 || char_pic == char_left2));
      }

      // move down
      if (is_key_down && (char_y_pos + char_speed >= 0) && (char_y_pos + char_speed <= 436)) {
        char_y_pos += char_speed;

        changeSteps(false, false, false);
      }

      // move left
      if (is_key_left && (char_x_pos - char_speed >= 0) && (char_x_pos - char_speed <= 636)) {
        char_x_pos -= char_speed;

        changeSteps(false, true, (char_pic == char_right1 || char_pic == char_right2));
      }
    }
  }


  /**
   * Changes the steps of the character to create an animation of the character walking.
   * 
   * @param is_moving_right Boolean representing if the user wants to move the character right
   * @param is_moving_left Boolean representing if the user wants to move the character left
   * @param is_changing Boolean that's true if the character is changing directions horizontally
   *   (i.e. if the character is moving from right to left or vice versa)
   */
  function changeSteps(is_moving_right, is_moving_left, is_changing) {
    // determine if steps are changed
    if (step_counter % step_change == 0 || is_changing) {
      if (!is_moving_right && !is_moving_left) {  // i.e. moving up or down
        if (is_right1) {
          // change char pic
          char_pic = char_right2;
          
          is_right2 = true;
          is_right1 = false;
        } else if (is_right2) {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_right2 = false;
        } else if (is_left1) {
          // change char pic
          char_pic = char_left2;

          is_left2 = true;
          is_left1 = false;
        } else if (is_left2) {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_left2 = false;
        }
      } else if (is_moving_right && !is_moving_left) {
        if (is_right1) {
          // change char pic
          char_pic = char_right2;
          
          is_right2 = true;
          is_right1 = false;
        } else if (is_right2) {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_right2 = false;
        } else {
          // change char pic
          char_pic = char_right1;

          is_right1 = true;
          is_left1 = false;
          is_left2 = false;
        }
      } else if (is_moving_left && !is_moving_right) {
        if (is_left1) {
          // change char pic
          char_pic = char_left2;
          
          is_left2 = true;
          is_left1 = false;
        } else if (is_left2) {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_left2 = false;
        } else {
          // change char pic
          char_pic = char_left1;

          is_left1 = true;
          is_right1 = false;
          is_right2 = false;
        }
      }
    }
  }


  // check if the character landed in any zoom in area
  function zoomInOnItem() {
    
    if (scene_pic == bedroom_scene && char_x_pos >= whiteboard_left_bound &&
      char_x_pos <= whiteboard_right_bound && char_y_pos <= whiteboard_bottom_bound) {
        // zoom into whiteboard
        scene_pic = whiteboard_scene;

        // update values
        is_whiteboard_scene = true;
        is_bedroom_scene = false;
    }

    if (scene_pic == livingroom_scene && char_x_pos >= computer_left_bound && 
      char_x_pos <= computer_right_bound && char_y_pos <= computer_bottom_bound &&
      char_y_pos >= computer_top_bound) {
      
      if (!is_computer_unlocked) {
        // show computer lock screen
        scene_pic = computer_scene;
        is_computer_scene = true;
        is_livingroom_scene = false;
      } else {
        // show terminal
        scene_pic = terminal_scene;
        is_terminal_scene = true;
        is_livingroom_scene = false;
      }
    }

    if (scene_pic == kitchen_scene && char_x_pos >= combo_lock_left_bound &&
      char_x_pos <= combo_lock_right_bound && char_y_pos <= combo_lock_bottom_bound &&
      char_y_pos >= combo_lock_top_bound) {
        
      if (!is_lock_unlocked) {
        scene_pic = combo_lock_scene
        is_combo_lock_scene = true;
        is_kitchen_scene = false;
      }

    }

    if (scene_pic == kitchen_scene && char_x_pos >= fridge_left_bound &&
      char_x_pos <= fridge_right_bound && char_y_pos <= fridge_bottom_bound &&
      char_y_pos >= fridge_top_bound) {

      scene_pic = fridge_scene;
      is_fridge_scene = true;
      is_kitchen_scene = false;
    }

    if (scene_pic == kitchen_scene && char_x_pos >= toaster_left_bound &&
      char_x_pos <= toaster_right_bound && char_y_pos <= toaster_bottom_bound &&
      char_y_pos >= toaster_top_bound) {

      scene_pic = toaster_scene;
      is_toaster_scene = true;
      is_kitchen_scene = false;
    }

    if (scene_pic == kitchen_scene && char_x_pos >= coffee_maker_left_bound &&
      char_x_pos <= coffee_maker_right_bound && char_y_pos <= coffee_maker_bottom_bound &&
      char_y_pos >= coffee_maker_top_bound) {

      scene_pic = coffee_maker_scene;
      is_coffee_maker_scene = true;
      is_kitchen_scene = false;
    }
  }


  /* RECORD KEY DOWNS (specifically character movements) */
  // source for recording key downs: https://stackoverflow.com/questions/39806858/how-to-use-arrow-keys-to-move-object-smoothly-in-canvas
  // source for stopping scrolling when using arrow keys: https://stackoverflow.com/questions/40905098/how-to-stop-scrolling-while-html5-game-is-playing
  document.onkeydown = function(event) {
    if (event.code === "ArrowUp") {
      is_key_up = true;
      event.preventDefault();
    }

    if (event.code === "ArrowRight") {
      is_key_right = true;
      event.preventDefault();
    }

    if (event.code === "ArrowDown") {
      is_key_down = true;
      event.preventDefault();
    }

    if (event.code === "ArrowLeft") {
      is_key_left = true;
      event.preventDefault();
    }
  }

  document.onkeyup = function(event) {
    if (event.code === "ArrowUp") {
      is_key_up = false;
    }

    if (event.code === "ArrowRight") {
      is_key_right = false;
    }

    if (event.code === "ArrowDown") {
      is_key_down = false;
    }

    if (event.code === "ArrowLeft") {
      is_key_left = false;
    }
  }


  /* RECORD KEY DOWNS (i.e. for closing windows, hints, etc) */
  // special key down - escape the zoomed in window, hints etc
  document.addEventListener('keydown', logKey)

  function logKey(key) {
    
    if (key.code === "Escape") {
      if (is_whiteboard_scene) {
        // zoom out of whiteboard
        scene_pic = current_room;
        
        // need the following to prevent the character from triggering the zoom in again
        moveOutOfDetectionZone(whiteboard_left_bound, whiteboard_right_bound, whiteboard_bottom_bound, whiteboard_top_bound);

        // update values
        is_whiteboard_scene = false;
        if (current_room === bedroom_scene) {
          is_bedroom_scene = true;
        }
      }

      if (is_computer_scene) {  
        // zoom out of computer
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(computer_left_bound, computer_right_bound, computer_bottom_bound, computer_top_bound);

        // update values of the game scene
        is_computer_scene = false;
        if (current_room === livingroom_scene) {
          is_livingroom_scene = true;
        }

        // clear text
        computer_password_string = " ";
        if (is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = false;
        }
      }

      if (is_combo_lock_scene) {
        // zoom out of combo lock
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(combo_lock_left_bound, combo_lock_right_bound, combo_lock_bottom_bound, combo_lock_top_bound);

        // update values
        is_combo_lock_scene = false;
        if (current_room === kitchen_scene) {
          is_kitchen_scene = true;
        }

        // clear text
        lock_combo_string = " ";
        if (is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = false;
        }
      }

      if (is_fridge_scene) {
        // zoom out of fridge
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(fridge_left_bound, fridge_right_bound, fridge_bottom_bound, fridge_top_bound);

        // update values
        is_fridge_scene = false;
        if (current_room === kitchen_scene) {
          is_kitchen_scene = true;
        }
      }

      if (is_toaster_scene) {
        // zoom out of toaster
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(toaster_left_bound, toaster_right_bound, toaster_bottom_bound, toaster_top_bound);

        // update values
        is_toaster_scene = false;
        if (current_room === kitchen_scene) {
          is_kitchen_scene = true;
        }
      }

      if (is_coffee_maker_scene) {
        // zoom out of toaster
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(coffee_maker_left_bound, coffee_maker_right_bound, coffee_maker_bottom_bound, coffee_maker_top_bound);

        // update values
        is_coffee_maker_scene = false;
        if (current_room === kitchen_scene) {
          is_kitchen_scene = true;
        }
      }

      if (is_terminal_scene) {
        // zoom out of terminal
        scene_pic = current_room;

        // move out of the zone that triggered zoom in
        moveOutOfDetectionZone(computer_left_bound, computer_right_bound, computer_bottom_bound, computer_top_bound);

        // update values
        is_terminal_scene = false;
        if (current_room === livingroom_scene) {
          is_livingroom_scene = true;
        }

        // reset terminal history
        current_directory = "~";
        directory_archive = ["~"];
        terminal_archive = [""];
        user_input = "";

        // remove text from terminal display - https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        while (num_inputs > 0) {
          let terminal_line = document.getElementById("input" + num_inputs);
          game_terminal.removeChild(terminal_line);

          let output_line = document.getElementById("output" + (num_inputs - 1));
          game_terminal.removeChild(output_line);
          
          --num_inputs;
        }
        input_number = num_inputs;
      }  // closing terminal conditional

    }  // closing the escape key conditional

    if (key.code === "Backspace") {

      if (is_combo_lock_scene) {
        if (is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = false;
        }

        if (lock_combo_string.length > 0) {
          // user only needs to delete the numbers they inputted, not the spaces
          if (lock_combo_string[lock_combo_string.length - 1] == " ") {
            lock_combo_string = lock_combo_string.substring(0, lock_combo_string.length - 1);
          }

          // delete a character
          lock_combo_string = lock_combo_string.substring(0, lock_combo_string.length - 1);
        }
      }  // closing lock scene conditional

      if (is_computer_scene) {
        if (is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = false;
        }

        if (computer_password_string.length <= 1) {
          // keep the blank space
          computer_password_string = " ";
        } else {
          // delete a character
          computer_password_string = computer_password_string.substring(0, computer_password_string.length - 1);
        }
      }  // closing computer scene conditional

      if (is_terminal_scene) {        
        // delete a character
        user_input = user_input.substring(0, user_input.length - 1);
      }

    }  // closing the backspace key conditional

    if (key.code === "Enter") {
      if (is_terminal_scene) {

        // execute user input
        let terminal_output = executeUserInput();
        displayTerminalOutput(terminal_output);

        // create new divider to hold next line of user input
        // source1: https://www.encodedna.com/javascript/append-or-add-text-to-div-using-javascript.htm
        // source2: https://developer.mozilla.org/en-US/docs/Web/API/Element/append
        let new_divider = document.createElement("div");
        ++num_inputs;
        new_divider.id = "input" + num_inputs;

        // display current directory for new line
        let directory_display = getFullDirectory()
        let text = document.createTextNode(directory_display);
        new_divider.appendChild(text);

        game_terminal.append(new_divider);
        game_terminal.scrollTop = game_terminal.scrollHeight;  // scroll down to show the newly added element/line

        // reset user input text
        user_input = "";
        terminal_archive.push(user_input);
        input_number = num_inputs;

      } else {
        checkPasswordCorrectness();
      }
    }

    // check for key downs for alphanumeric characters
    updateUserInput(key);

  }  // closing log key function


  // moves the character out of the area that would trigger the zoom in again
  function moveOutOfDetectionZone(left_bound, right_bound, bottom_bound, top_bound) {
    // the following conditionals essentially check which direction the character
    // approached the item that caused it to zoom in; these checks will require
    // the user to only press 'ESCAPE' once when they want to close the window

    if (char_y_pos <= bottom_bound && char_y_pos + char_speed > bottom_bound) {
      // came from bottom
      char_y_pos += char_speed;
    } else if (char_x_pos >= left_bound && char_x_pos - char_speed < left_bound) {
      // came from left
      char_x_pos -= char_speed;
    } else if (char_x_pos <= right_bound && char_x_pos + char_speed > right_bound) {
      // came from right
      char_x_pos += char_speed;
    } else if (char_y_pos >= top_bound && char_y_pos - char_speed < top_bound) {
      // came from top
      char_y_pos -= char_speed;
    }
  }


  // initial loading and drawing of background
  function loadBackground(img_url) {
    const background_img = new Image();
    background_img.src = img_url;

    // load images first
    // - Note: the following line is needed to fix the problem of the background img not always
    // displaying when the page is refreshed
    // - Source: https://stackoverflow.com/questions/22889641/simple-html5-canvas-image-not-displaying
    background_img.addEventListener("load", drawBackground, false);

    console.log("loaded")

    function drawBackground() {
      console.log("drawing")

      // parameters of drawImage: image, x-coord-of-img, y-coord-of-img, img-width, img-height
      // game_context.drawImage(background_img, sx=0, sy=0, swidth=700, sheight=500);
      
      // draw(background_img, 0, 0, 700, 500)  // might not need...?

      console.log("finished")
    }

    return background_img;
    console.log("DRAWN");
  }


  // general function to initially load and draw components (i.e. character)
  function loadCharacter(img_url, x, y, width, height) {
    const img = new Image();
    img.src = img_url;

    // load images first
    // - Note: the following line is needed to fix the problem of the background img not always
    // displaying when the page is refreshed
    // - Source: https://stackoverflow.com/questions/22889641/simple-html5-canvas-image-not-displaying
    img.addEventListener("load", drawCharacter, false); 

    function drawCharacter() {
      // parameters of drawImage: image, x-coord-of-img, y-coord-of-img, img-width, img-height
      // game_context.drawImage(img, sx=x, sy=y, swidth=width, sheight=height);
      
      // draw(img, x, y, width, height);  // might not need...?
    }

    return img;
  }


  // need this function for redrawing images in infinite loop
  function draw(img, x, y, width, height) {
    game_context.drawImage(img, sx=x, sy=y, swidth=width, sheight=height);
  }

  console.log("OUT");


  // Things to consider when incorporating the changing rooms:
  // done - load the background + make corresponding variables 
  // done- add room variables to conditional that prevents character from being drawn
  //   if not in a room
  // done - add room variables to conditional in 'moveCharacter()' function to prevent     
  //   the character's position from updating when zoomed into an item 
  // done- remember to change the 'current_room' variable when the rooms change
  // done- if planning on incorporating zoom-ins, don't forget to...
  //   - create constants that represent the bounds
  //   - add the conditional for it to zoom in in the 'zoomInOnItem()' function
  //   - add to the conditional for the 'ESCAPE' key down in the 'logKey()' function
  // done- when determining how to detect when to change the rooms, don't need to 
  //   change any outer bounds (i.e. room bounds), just need to add in bounds
  //   that would represent the doorways (i.e. x or y positions)

  
  function changeRooms() {

    if (scene_pic == bedroom_scene && ((char_y_pos >= 125 && char_y_pos <= 205) && char_x_pos <= 5)){
      scene_pic = livingroom_scene;
      current_room = livingroom_scene;
      char_x_pos = 625;
      char_y_pos = 125
      is_bedroom_scene = false;
      is_livingroom_scene = true;
    }

    if (scene_pic == livingroom_scene && ((char_x_pos >= 500 && char_x_pos <= 590) && char_y_pos <= 5) ){
      scene_pic = kitchen_scene;
      current_room = kitchen_scene;
      char_x_pos = 330;
      char_y_pos = 420;
      is_kitchen_scene = true;
      is_livingroom_scene = false;
    }

    if (scene_pic == kitchen_scene && ((char_x_pos >= 280 && char_x_pos <= 380) && char_y_pos >= 430)){
      scene_pic = livingroom_scene;
      current_room = livingroom_scene;
      char_x_pos = 555;
      char_y_pos = 10;
      is_kitchen_scene = false;
      is_livingroom_scene = true;
    }

    if (scene_pic == livingroom_scene && ((char_y_pos >= 107 && char_y_pos <= 160) && char_x_pos >= 630) ){
      scene_pic = bedroom_scene;
      current_room = bedroom_scene;
      char_x_pos = 10;
      char_y_pos = 155;
      is_bedroom_scene = true;
      is_livingroom_scene = false;
    }

  }


  /* FUNCTIONS FOR PUZZLES */
  // displays text user types
  function displayUserInput() {

    if (is_combo_lock_scene) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "black";
      game_context.fillText(lock_combo_string, 290, 443);
    }

    if (is_computer_scene) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "black";
      game_context.fillText(computer_password_string, 144, 270);
    }

    if (is_terminal_scene) {
      // source: https://developer.mozilla.org/en-US/docs/Web/API/Node/replaceChild

      // create the replacement elements
      let replacement_divider = document.createElement("div");
      let directory_display = getFullDirectory();
      let replacement_text = document.createTextNode(directory_display + user_input);
      replacement_divider.appendChild(replacement_text);

      // retrieve the element to replace
      let divider_to_replace = document.getElementById("input" + num_inputs);

      // rename dividers so new divider will have original divider name (for consistency)
      divider_to_replace.id = "old" + num_inputs;
      replacement_divider.id = "input" + num_inputs;

      // replace current input line with updated user input
      game_terminal.replaceChild(replacement_divider, divider_to_replace);
    }

  }

  function displayIncorrectMessage() {

    if (is_lock_combo_incorrect_message_visible) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "red";
      game_context.fillText("Combo incorrect. Please try again.", 150, 480);
    }

    if (is_password_incorrect_message_visible) {
      game_context.font = "25px Comic Sans MS";
      game_context.fillStyle = "red";
      game_context.fillText("Password incorrect. Please try again.", 130, 350);
    }

  }

  function updateUserInput(key) {

    if (key.code === "Space") {
      key.preventDefault();
    }

    if (is_combo_lock_scene) {
      if (allowed_combo_keys.includes(key.which) && lock_combo_string.length < 9) {
        // remove incorrect message text
        if (is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = false;
        }

        // automatically add spaces between numbers for user
        if ((lock_combo_string.length) % 3 == 0) {
          lock_combo_string += " ";
        }

        // add user input
        lock_combo_string += String.fromCharCode(key.which);
      }
    }  // closing lock conditional

    if (is_computer_scene) {
      if (allowed_password_keys.includes(key.which) && computer_password_string.length < 18) {
        // remove incorrect message text
        if (is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = false;
        }

        // add user input
        computer_password_string += String.fromCharCode(key.which);
      }    
    }  // closing computer password conditional

    if (is_terminal_scene) {
      
      if (key.key === "Shift" ||
          key.key === "Alt" ||
          key.key === "Meta" ||
          key.key === "Control" ||
          key.key === "Backspace" ||
          key.key === "Enter" ||
          key.key === "ArrowRight" ||
          key.key === "ArrowLeft" ||
          key.key === "Escape" ||
          key.key === "CapsLock" ||
          key.key === "Tab") {
        // do nothing
      } else if (key.key === "ArrowUp") {
        // display previous terminal command from current command
        if (input_number - 1 >= 0) {
          user_input = terminal_archive[input_number - 1];
          --input_number;
        }
      } else if (key.key === "ArrowDown") {
        // display next terminal command from current command
        if (input_number + 1 <= num_inputs) {
          user_input = terminal_archive[input_number + 1];
          ++input_number;
        }
      } else {
        // add to user input and store it
        user_input += key.key;
        terminal_archive[num_inputs] = user_input;

        // make new command typed out the most recent command (used
        // for arrowup and arrowdown keys for viewing terminal archive)
        input_number = num_inputs;
      }
    }  // closing terminal conditional

  }

  // check passwords
  function checkPasswordCorrectness() {

    if (!is_lock_unlocked && is_combo_lock_scene) {
      if (lock_combo_string === " 86 37 49") {  // correct combo

        // zoom out of cabinet
        scene_pic = current_room;
        is_kitchen_scene = true;

        moveOutOfDetectionZone(combo_lock_left_bound, combo_lock_right_bound, combo_lock_bottom_bound, combo_lock_top_bound);

        if (scene_pic === kitchen_scene) {
          is_combo_lock_scene = false;
        }

        // update status of puzzle
        is_lock_unlocked = true;

      } else {  // incorrect combo
        if (!is_lock_combo_incorrect_message_visible) {
          is_lock_combo_incorrect_message_visible = true;
        }
      }
    }  // closing lock conditional

    if (!is_computer_unlocked && is_computer_scene) {
      if (computer_password_string === " DELILAH") {

        // show terminal
        scene_pic = terminal_scene;
        is_terminal_scene = true;
        is_computer_scene = false;

        // update status of computer => unlocked
        is_computer_unlocked = true;

      } else {  // incorrect password
        if (!is_password_incorrect_message_visible) {
          is_password_incorrect_message_visible = true;
        }
      }

    }  // closing computer password conditional

  }  // closing check password correctness function


  // execute user input by outputting corresponding messages
  function executeUserInput() {
    let command_to_process = [];
    if (user_input.trim() != "") {
      command_to_process = user_input.split(" ");
    }
    let output_text = "";

    let subdirectories = directory[current_directory]["directories"];
    let executables_in_current = directory[current_directory]["executables"];

    // check commands
    if (command_to_process.length != 0) {  // only check commands if command exists
      
      if (currently_in_executable) {
        output_text = executeExecutable(command_to_process);
      } else if (command_to_process[0] === "cd") {
        output_text = executeCdCommand(command_to_process, subdirectories);
      } else if (command_to_process[0] == "ls") {
        if (command_to_process.length == 1) {  // "ls"

          // display subdirectories and executables in current directory
          for (let i = 0; i < subdirectories.length; ++i) {
            output_text += subdirectories[i] + " ";
          }

          for (let j = 0; j < executables_in_current.length; ++j) {
            output_text += executables_in_current[j] + " ";
          }
        }
      } else if (command_to_process[0].slice(0, 2) === "./") {

        // check if given executable is in the current directory
        if (checkExecutableExistence(executables_in_current, command_to_process[0].slice(2))) {
          currently_in_executable = true;
          curr_executable_name = command_to_process[0].slice(2);
          console.log(curr_executable_name)
          output_text = getExecutableWelcomeMessage();
        } else {
          output_text = "Error: specified executable does not exist.";
        }

      } else if (command_to_process.length === 1 && command_to_process[0] === "exit") {
        output_text = "Error: nothing to exit from.";
      } else {
        output_text = "Error: invalid command";
      }

    }

    return output_text;
  }

  function executeCdCommand(command_to_process, subdirectories) {
    let output_text = "";

    if (command_to_process.length == 1) {  // "cd"

      // move to home directory if not already in it
      if (current_directory != "~") {
        current_directory = "~";
        directory_archive = ["~"];
      }

    } else if (command_to_process.length == 2) {  // "cd" + other command

      if (command_to_process[1] == "../") {  // "cd ../"
        if (current_directory != "~" && directory_archive.length != 1) {
          // move to parent/previous directory
          directory_archive.pop();
          current_directory = directory_archive[directory_archive.length - 1];
        }
      } else {  // check if it's a valid directory (i.e. if the user wants to move into a directory)
        let valid_directory = false;

        for (let s = 0; s < subdirectories.length; ++s) {
          if (subdirectories[s] === command_to_process[1]) {
            // change directory and save into archive
            current_directory = subdirectories[s];
            directory_archive.push(current_directory);
            valid_directory = true;
            break;
          }
        }

        if (!valid_directory) {
          output_text = "Error: specified directory not found.";
        }
      }

    }

    return output_text;
  }

  function executeExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1 && command_to_process[0] === "exit") {
      currently_in_executable = false;
      output_text = "Exiting current executable.";
    } else {
      // redirect to the specific executable
      if (curr_executable_name === "lineDolphin.exe") {
        output_text = executeLineDolphinExecutable(command_to_process);
      } else if (curr_executable_name === "coffeeRequestSender.exe") {
        // TODO: ADD CODE FOR EXECUTION HERE
      } else if (curr_executable_name === "fridgeLoginPortal.exe") {
        output_text = executeFridgeLoginExecutable(command_to_process);
      }
    }

    return output_text;
  }

  function executeLineDolphinExecutable(command_to_process) {
    let output_text = "";

    if (command_to_process.length === 1 && command_to_process[0] === "capture") {
      display_coffee_text = true;

      output_text = "STATUS: OK, READY TO BREW";
    } else {
      output_text = "Error: Invalid Command";
    }

    return output_text;
  }

  function executeFridgeLoginExecutable(command_to_process) {
    let output_text = "";
    if(command_to_process.length === 1 && command_to_process[0] === "stock"){

      output_text = "Current fridge contents: \n 1x baking soda. 6x bell pepper. 3x Golden Harbor Soup Dumplings. \n 1x half and half. 34x chicken eggs. 10x quail eggs.";
    }

    else if(command_to_process.length === 1 && command_to_process[0] === "lock"){
      
      if(fridge_is_locked){
        output_text = "Fridge is already locked!";
      }
      else{
        output_text = "Fridge locked!";
        fridge_is_locked = true;
      }
    }

    else if(command_to_process.length === 1 && command_to_process[0] === "unlock"){

      if(fridge_is_locked){
        output_text = "Fridge unlocked!";
        fridge_is_locked = false;
      }
      else{
        output_text = "Fridge is already unlocked!";
      }
    }

    else{
      output_text = "Error: Invalid Command!";
    }

    return output_text;
  }

  function checkExecutableExistence(executables_in_current, executable_name) {
    for (let i = 0; i < executables_in_current.length; ++i) {
      if (executable_name === executables_in_current[i]) {
        return true;
      }
    }

    return false;
  }

  function getExecutableWelcomeMessage() {
    if (curr_executable_name === "lineDolphin.exe") {
      return "Welcome to lineDolphin! Default configuration: display CyberCoffee traffic.";
    } else if (curr_executable_name === "coffeeRequestSender.exe") {
      return "Welcome to the coffee request portal! Here, one can send requests to the CYBA coffee brewer.";
    } else if (curr_executable_name === "fridgeLoginPortal.exe") {
      //return "Welcome to your smart fridge portal! Your username is GreenStreet. However, to access fridge features, you must authenticate yourself.";
      return "Welcome to your smart fridge control portal!";
    }
  }

  // display output message for a terminal command
  function displayTerminalOutput(output_text) {
    // create divider to store output
    let output_divider = document.createElement("div");
    output_divider.id = "output" + num_inputs;

    if (display_coffee_text) {
      // output coffee brew message
      for (let i=0; i < coffee_text.length; ++i) {
        let line_of_coffee_text = document.createTextNode(coffee_text[i]);
        output_divider.appendChild(line_of_coffee_text);
        output_divider.appendChild(document.createElement("br"))
      }

      display_coffee_text = false;
    }

    // display output text
    let text = document.createTextNode(output_text);
    output_divider.appendChild(text);

    // add to terminal
    game_terminal.append(output_divider);
  }

  // returns a string of the full directory to display in terminal
  function getFullDirectory() {
    let directory_string = directory_archive[0];  // "~" directory

    if (currently_in_executable) {
      directory_string = curr_executable_name + "> ";
    } else {
      // add in rest of directories
      for (let dir = 1; dir < directory_archive.length; ++dir) {
        directory_string += "/" + directory_archive[dir]; 
      }

      directory_string += "$ ";
    }

    return directory_string;
  }




  // Notes for incorporating password puzzles:
  // done - create a variable containing an array of allowed keys (can use same as last year's)
  // done - create associated variables for keeping track of the password, incorrect message, and
  //   whether item has been unlocked
  // done - add conditional that prevents zoom in once puzzle is solved in zoomInOnItem()
  // done - add line that clears the text in ESCAPE key down for the item
  // done - add conditional for item in BACKSPACE key down (code should be similar to that of last year)
  // - add respective text/code to...
  // done  - updateUserInput()
  // done  - displayUserInput() /
      //check positioning of password
  // done  - displayIncorrectMessage()
  // done - checkPasswordCorrectness()
  //     - code should be similar to that of last year--refer to line 215 in original code


  //done - Suggested sequence that I kind of followed when trying to implement the puzzle:
  // - adjust text size and position using a default text (i.e. set the variable to
  //   some phrase for testing without taking in user input yet)
  // - incorporate taking user input
  // - incorporate key downs for backspace, enter, etc


  // Notes to self (Megan):
  // - create helper function for closing out of lock scene (maybe)


  // Notes for terminal implementation (7/3):
  // DONE - render and position terminal
  // DONE - find out how to wrap text when there is no space
  // DONE - remove browser detection for SPACE (like we did when using the arrow keys)
  // DONE - find way to keep track of user input so when commands like ESCAPE or RETURN
  //   are pressed, it performs the way it does in a terminal (i.e. clears terminal history
  //   and shows new line with directory)
  // DONE - set up display (~)
  // DONE - implement ENTER key down
  // DONE - take in user input
  // DONE - implement ESCAPE key down
  // DONE - fill in allowed keys
  //   DONE - fix these keys: minus, quote, period, slash
  // DONE - implement basic terminal commands
  //   DONE - cd
  //   DONE - ls
  //   DONE - cd ../
  //   DONE - KEY UP (to get previously used commands)
  //   DONE - KEY DOWN (to get next commands if looking at previous commands)
  // DONE - fix scrolling functionality (to have it scroll to show the line that is being written)
  // - adjust positioning and color of terminal (i.e. to make it look like it's being viewed
  //   from a computer)
  // - make sure functionality works properly (when using backspace and
  //   escaping the window)
  // - display a cursor for the user
  // - fix backspace key down for computer and combo puzzle


  // DURING LAST WEEK:
  // - remove commented out code
  // - remove console.logs
  // - check through all code + add missing comments + test thoroughly





  
  // THIRD ATTEMPT (similar to final attempt)
  // const bedroom_img = new Image();
  // bedroom_img.src = "images/bedroom.png";
  // bedroom_img.onload = () => {
  //   // parameters of drawImage: image, x-coord-of-img, y-coord-of-img, img-width, img-height
  //   game_context.drawImage(bedroom_img, 0, 0, 700, 500);
  // };



  // SECOND ATTEMPT
  // window.onload = function() {
  //   var canvas = document.getElementById("myCanvas");
  //   var ctx = canvas.getContext("2d");

  //   var gameScene = new Image();
  //   gameScene.src = "images/bedroom.png";
  //   ctx.drawImage(gameScene, 0, 0, 700, 500);
  // };



  // FIRST ATTEMPT
  // function startGame() {
  //     myGameArea.start();
  // }

  // var myGameArea = {
  //     myCanvas : document.createElement("myCanvas"),
  //     start : function() {
  //         // this.myCanvas.width = 700;
  //         // this.myCanvas.height = 500;
  //         this.context = this.myCanvas.getContext("2d");
  //         document.body.insertBefore(this.myCanvas, document.body.childNodes[0]);
  //     }
  // }

</script>

<p>We have created a game area! (or at least an empty canvas)</p>

<!--Add hints or description to bottom-->
  <p id="hintsText">Hints: press ? to get a new hint!</p>
  <br>
  <p id="hintsList"></p>
  <br>
  <div id="tastList">
    <p>Remaining tasks:</p>
    <p id="unlockComputer">- Unlock the computer &#128187</p>
    <p id="makeToast">- Make toast &#127838 </p>
    <p id="openFridge">- Open the fridge &#127859</p>
    <p id="makeCoffee">- Make coffee &#9749</p>
  </div>
  <br>
  <div id="resources">
    <p>Resources</p>
    <p><a href="guides/caesar_ciphers.pdf" target="_blank" rel="noopener noreferrer">On Caesar Ciphers</a></p>
    <p><a href="guides/number_systems_and_ascii.pdf" target="_blank" rel="noopener noreferrer">Number Systems and ASCII</a></p>
    <p><a href="guides/cli.pdf" target="_blank" rel="noopener noreferrer">Navigating a Command-Line Interface</a></p>
  </div>

</body>
</html>